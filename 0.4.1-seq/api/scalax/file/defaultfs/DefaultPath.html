<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>scalax.file.defaultfs.DefaultPath</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../lib/template.css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/class_big.png" />
        <p id="owner"><a name="scalax" class="extype" href="../../package.html">scalax</a>.<a name="scalax.file" class="extype" href="../package.html">file</a>.<a name="scalax.file.defaultfs" class="extype" href="package.html">defaultfs</a></p>
        <h1>DefaultPath</h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="kind">class</span>
      <span class="symbol"> 
        <span class="name">DefaultPath</span>
        
        <span class="result"> extends <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> with <span name="scalax.file.defaultfs.DefaultFileOps" class="extype">DefaultFileOps</span></span>
      </span>
      </h4>
      
          <div class="fullcommenttop" id="comment"><div class="comment cmt"><p><b>Not Part of API</b></p><p>A file reference that locates a file using a system independent path.
The file is not required to exist.
</p></div><dl class="attributes block"> <dt>Self Type</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a></dd><dt>Since</dt><dd><p>1.0
</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span name="scalax.file.defaultfs.DefaultFileOps" class="extype">DefaultFileOps</span>, <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>, <span name="scala.math.Ordered" class="extype">Ordered</span>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>], <span name="java.lang.Comparable" class="extype">Comparable</span>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>], <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>], <a name="scalax.file.FileOps" class="extype" href="../FileOps.html">FileOps</a>, <a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a>, <a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a>, <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a>, AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div></div>
        

      <div id="template">

        <div id="mbrsel">
          <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
          <div id="order">
                <span class="filtertype">Ordering</span>
                <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
              </div>
          <div id="ancestors">
                <span class="filtertype">Inherited</span>
                <ol><li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show all</span></li></ol>
                <ol id="linearization"><li name="scalax.file.defaultfs.DefaultPath" class="in"><span>DefaultPath</span></li><li name="scalax.file.defaultfs.DefaultFileOps" class="in"><span>DefaultFileOps</span></li><li name="scalax.file.Path" class="in"><span>Path</span></li><li name="scala.math.Ordered" class="in"><span>Ordered</span></li><li name="java.lang.Comparable" class="in"><span>Comparable</span></li><li name="scalax.file.PathFinder" class="in"><span>PathFinder</span></li><li name="scalax.file.FileOps" class="in"><span>FileOps</span></li><li name="scalax.io.Seekable" class="in"><span>Seekable</span></li><li name="scalax.io.Output" class="in"><span>Output</span></li><li name="scalax.io.Input" class="in"><span>Input</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
              </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>

        

        
        
        

        <div class="values members" id="values">
              <h3>Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">##</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#*" data-isabs="false">
      <a id="*[F](F)(PathMatcherFactory[F]):PathSet[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">*</span>
        <span class="tparams">[<span name="F">F</span>]</span>
        <span class="params">(<span name="filter">filter: F</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="factory">factory: <a name="scalax.file.PathMatcherFactory" class="extype" href="../PathMatcherFactory.html">PathMatcherFactory</a>[F]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="../PathSet.html">PathSet</a>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Constructs a new finder that selects all paths with a name that matches <code>filter</code> and are
immediate children of paths selected by this finder.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a new finder that selects all paths with a name that matches <code>filter</code> and are
immediate children of paths selected by this finder.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#**" data-isabs="false">
      <a id="**[F](F)(PathMatcherFactory[F]):PathSet[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">**</span>
        <span class="tparams">[<span name="F">F</span>]</span>
        <span class="params">(<span name="filter">filter: F</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="factory">factory: <a name="scalax.file.PathMatcherFactory" class="extype" href="../PathMatcherFactory.html">PathMatcherFactory</a>[F]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="../PathSet.html">PathSet</a>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Constructs a new finder that selects all paths with a name that matches <code>filter</code> and are
descendants of paths selected by this finder.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a new finder that selects all paths with a name that matches <code>filter</code> and are
descendants of paths selected by this finder.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#***" data-isabs="false">
      <a id="***:PathSet[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">***</span>
        
        <span class="result">: <a name="scalax.file.PathSet" class="extype" href="../PathSet.html">PathSet</a>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#+++" data-isabs="false">
      <a id="+++[U&gt;:Path](PathFinder[U]):PathSet[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">+++</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>]</span>
        <span class="params">(<span name="includes">includes: <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a>[U]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="../PathSet.html">PathSet</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The union of the paths found by this <code>PathSet</code> with the paths found by 'paths'.</p><div class="fullcomment"><div class="comment cmt"><p>The union of the paths found by this <code>PathSet</code> with the paths found by 'paths'.
Note that if the same element is added twice it will be present twice in the PathFinder
(in most implementations).  Consider: (Path(&quot;a&quot;) +++ Path(&quot;a&quot;)).iterator.  the iterator
will return Path(&quot;a&quot;) twice.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#---" data-isabs="false">
      <a id="---[U&gt;:Path](PathFinder[U]):PathSet[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">---</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>]</span>
        <span class="params">(<span name="excludes">excludes: <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a>[U]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="../PathSet.html">PathSet</a>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Excludes all paths from <code>excludes</code> from the paths selected by this <code>PathSet</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Excludes all paths from <code>excludes</code> from the paths selected by this <code>PathSet</code>.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#/" data-isabs="false">
      <a id="/(String):DefaultPath"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">/</span>
        
        <span class="params">(<span name="child">child: String</span>)</span><span class="result">: <a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If child is relative, creates a new Path based on the current path with the
child appended.</p><div class="fullcomment"><div class="comment cmt"><p>If child is relative, creates a new Path based on the current path with the
child appended. If child is absolute the child is returned</p><p>&lt;</p><ul><li>if other is null return this</li><li>if other is absolute return other</li><li>if other is not absolute the return this append other</li></ul><p><strong>@note child is a single child if it contains a path separator it will NOT be considered a separator character</strong></p><p>Examples include:
<pre>
<code>
path / "child" / "grandchild"
path / ".." / "sibling"
</code>
</pre></p><p>Illegal examples include;
<pre>
<code>
path / "child/grandchild"
path / "../sibling"
</code>
</pre>
In these cases an exception will be thrown</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A new path with the specified path appended
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a></dd><dt>See also</dt><dd><span class="cmt"><p>#\(String)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#/" data-isabs="false">
      <a id="/(Path):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">/</span>
        
        <span class="params">(<span name="child">child: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Alias for /(child.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for /(child.name)
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A new path with the specified path appended</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>#/(String)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#/" data-isabs="false">
      <a id="/(String,Char):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">/</span>
        
        <span class="params">(<span name="pathRepresentation">pathRepresentation: String</span>, <span name="separator">separator: <span name="scala.Char" class="extype">Char</span></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Add several children to this path.</p><div class="fullcomment"><div class="comment cmt"><p>Add several children to this path.  The sep character will be used to split the path string,
A path will be created from the resulting sequence and finally all children will be added to this path.</p><p>Examples:</p><pre>
path / (&quot;a,c,d,e&quot;, ',') // results in path / a / c / d / e
path / (&quot;/a/b/c/d/&quot;, '/') // results in path / a / b / c / d
path / (&quot;//../a&quot;,&quot;/&quot;) // results in path / .. / a

path / (&quot;/a&quot;,',') // results in an exception if / == Path.separator
path / (&quot;//&quot;,'/') // returns same Path
</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#&lt;" data-isabs="false">
      <a id="&lt;(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">&lt;</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered</dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#&lt;=" data-isabs="false">
      <a id="&lt;=(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">&lt;=</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#&gt;" data-isabs="false">
      <a id="&gt;(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">&gt;</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered</dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#&gt;=" data-isabs="false">
      <a id="&gt;=(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">&gt;=</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#\" data-isabs="false">
      <a id="\(Path):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">\</span>
        
        <span class="params">(<span name="child">child: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Alias for /(Path)</p><div class="fullcomment"><div class="comment cmt"><p>Alias for /(Path)</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>#/(Path)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#\" data-isabs="false">
      <a id="\(String,Char):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">\</span>
        
        <span class="params">(<span name="pathRepresentation">pathRepresentation: String</span>, <span name="separator">separator: <span name="scala.Char" class="extype">Char</span></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#\" data-isabs="false">
      <a id="\(String):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">\</span>
        
        <span class="params">(<span name="child">child: String</span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Alias for /(String)
</p><div class="fullcomment"><div class="comment cmt"><p>Alias for /(String)
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a></dd><dt>See also</dt><dd><span class="cmt"><p>/(String)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#access" data-isabs="false">
      <a id="access:AccessSet"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">access</span>
        
        <span class="result">: <a name="scalax.file.AccessSet" class="extype" href="../AccessSet.html">AccessSet</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Reads the access modes from the file and returns the Set
This does not lock the file so the modes could be out of date
even by the time the method returns if used in a heavily
parallel environment
</p><div class="fullcomment"><div class="comment cmt"><p>Reads the access modes from the file and returns the Set
This does not lock the file so the modes could be out of date
even by the time the method returns if used in a heavily
parallel environment
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the access modes set on the file
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#access_=" data-isabs="false">
      <a id="access_=(Iterable[AccessMode]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">access_=</span>
        
        <span class="params">(<span name="accessModes">accessModes: Iterable[<a name="scalax.file.Path.AccessModes.AccessMode" class="extype" href="../Path$$AccessModes$$AccessMode.html">AccessMode</a>]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the standard access modes on the underlying path.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the standard access modes on the underlying path.  If the
underlying object does not exist it will throw an exception.
If the underlying system does not support support the mode the mode
will be ignored
</p></div><dl class="paramcmts block"><dt class="param">accessModes</dt><dd class="cmt"><p>
         the modes to set on the file in (if possible)
         a single atomic update
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#access_=" data-isabs="false">
      <a id="access_=(String):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">access_=</span>
        
        <span class="params">(<span name="accessModes">accessModes: String</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Short cut for setting the standard access modes on the underlying path.</p><div class="fullcomment"><div class="comment cmt"><p>Short cut for setting the standard access modes on the underlying path.  If the
underlying object does not exist it will throw an exception.
If the underlying system does not support support the mode the mode
will be ignored
</p></div><dl class="paramcmts block"><dt class="param">accessModes</dt><dd class="cmt"><p>
         string representation of the modes. The standard options
         include r - read, w - write, e - execute.  The options are
         filesystem dependent
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#append" data-isabs="false">
      <a id="append(String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">append</span>
        
        <span class="params">(<span name="string">string: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Append a string to the end of the Seekable object.</p><div class="fullcomment"><div class="comment cmt"><p>Append a string to the end of the Seekable object.
</p></div><dl class="paramcmts block"><dt class="param">string</dt><dd class="cmt"><p>
         the data to write</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         the codec of the string to be written. The string will
         be converted to the encoding of <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#append" data-isabs="false">
      <a id="append[T](T)(OutputConverter[T]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">append</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="data">data: T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="converter">converter: <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a>[T]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Append bytes to the end of a file</p><div class="fullcomment"><div class="comment cmt"><p>Append bytes to the end of a file</p><p><b>Important:</b> The use of an Array is highly recommended
 because normally arrays can be more efficiently written using
 the underlying APIs
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>
         The data to write.  This can be any type that has a <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> associated
         with it.  There are predefined $outputConverters for several types.  See the
         <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object for the predefined types and for objects to simplify implementing
         custom <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a></p><p>$converterParam
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.io.Seekable#appendChannel" data-isabs="false">
      <a id="appendChannel[U]((SeekableByteChannel) ⇒ U):U"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">appendChannel</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (<a name="scalax.io.SeekableByteChannel" class="extype" href="../../io/SeekableByteChannel.html">SeekableByteChannel</a>) ⇒ U</span>)</span><span class="result">: U</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#appendIntsAsBytes" data-isabs="false">
      <a id="appendIntsAsBytes(Int*):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">appendIntsAsBytes</span>
        
        <span class="params">(<span name="data">data: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Since the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Since the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.  In other words just taking the first
 byte.  This is pretty common in Java.io style IO.  IE</p><pre>
 outputStream.write(1) 
</pre><p> 1 is written as a single byte.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#appendStrings" data-isabs="false">
      <a id="appendStrings(Traversable[String],String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">appendStrings</span>
        
        <span class="params">(<span name="strings">strings: <span name="scala.collection.Traversable" class="extype">Traversable</span>[String]</span>, <span name="separator">separator: String = <span class="symbol">&quot;&quot;</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Append several strings to the end of the Seekable object.</p><div class="fullcomment"><div class="comment cmt"><p>Append several strings to the end of the Seekable object.
</p></div><dl class="paramcmts block"><dt class="param">strings</dt><dd class="cmt"><p>
         The strings to write</p></dd><dt class="param">separator</dt><dd class="cmt"><p>
         A string to add between each string.
         It is not added to the before the first string
         or after the last.</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         The codec of the strings to be written. The strings will
         be converted to the encoding of <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">asInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#assertExists" data-isabs="false">
      <a id="assertExists:Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">assertExists</span>
        
        <span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#attributes" data-isabs="false">
      <a id="attributes:Set[scalax.file.attributes.FileAttribute[_]]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">attributes</span>
        
        <span class="result">: Set[scalax.file.attributes.FileAttribute[_]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#attributes_=" data-isabs="false">
      <a id="attributes_=(Iterable[scalax.file.attributes.FileAttribute[_]]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">attributes_=</span>
        
        <span class="params">(<span name="attrs">attrs: Iterable[scalax.file.attributes.FileAttribute[_]]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#blocks" data-isabs="false">
      <a id="blocks(Option[Int]):LongTraversable[ByteBlock]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">blocks</span>
        
        <span class="params">(<span name="blockSize">blockSize: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Int" class="extype">Int</span>] = <span class="symbol"><span class="name"><a href="../../../scala/package.html">None</a></span></span></span>)</span><span class="result">: <a name="scalax.io.LongTraversable" class="extype" href="../../io/LongTraversable.html">LongTraversable</a>[<a name="scalax.io.ByteBlock" class="extype" href="../../io/ByteBlock.html">ByteBlock</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Read the input as blocks of bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Read the input as blocks of bytes.  This method should be avoided unless the maximum performance is
absolutely required because bytes provides very good performance and is a better API for most applications.</p><p>However since it better reflects how data is read with most input sources (like InputStreams and ReadableByteChannels);
blocks is slightly more performance than bytes and therefore
can be used when performance is the most important consideration.
</p></div><dl class="paramcmts block"><dt class="param">blockSize</dt><dd class="cmt"><p>block size can optionally be specified but the default is normally acceptable.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a> → <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Input#byteArray" data-isabs="false">
      <a id="byteArray:Array[Byte]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">byteArray</span>
        
        <span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Byte" class="extype">Byte</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">This method aspires to be the fastest way to read
a stream of known length into memory.</p><div class="fullcomment"><div class="comment cmt"><p>This method aspires to be the fastest way to read
a stream of known length into memory.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#bytes" data-isabs="false">
      <a id="bytes:LongTraversable[Byte]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">bytes</span>
        
        <span class="result">: <a name="scalax.io.LongTraversable" class="extype" href="../../io/LongTraversable.html">LongTraversable</a>[<span name="scala.Byte" class="extype">Byte</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtains a Traversable for conveniently processing the resource as bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Obtains a Traversable for conveniently processing the resource as bytes.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an non-strict traversable over all the bytes
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a> → <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#bytesAsInts" data-isabs="false">
      <a id="bytesAsInts:LongTraversable[Int]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">bytesAsInts</span>
        
        <span class="result">: <a name="scalax.io.LongTraversable" class="extype" href="../../io/LongTraversable.html">LongTraversable</a>[<span name="scala.Int" class="extype">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtains a Traversable for conveniently processing the file as Ints.</p><div class="fullcomment"><div class="comment cmt"><p>Obtains a Traversable for conveniently processing the file as Ints.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an non-strict traversable over all the bytes with the bytes being represented as Ints
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a> → <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#canExecute" data-isabs="false">
      <a id="canExecute:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">canExecute</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#canRead" data-isabs="false">
      <a id="canRead:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">canRead</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#canWrite" data-isabs="false">
      <a id="canWrite:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">canWrite</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultFileOps#channel" data-isabs="false">
      <a id="channel(OpenOption*):SeekableByteChannelResource[SeekableFileChannel]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">channel</span>
        
        <span class="params">(<span name="openOptions">openOptions: <a name="scalax.io.OpenOption" class="extype" href="../../io/OpenOption.html">OpenOption</a>*</span>)</span><span class="result">: <a name="scalax.io.managed.SeekableByteChannelResource" class="extype" href="../../io/managed/SeekableByteChannelResource.html">SeekableByteChannelResource</a>[<a name="scalax.io.nio.SeekableFileChannel" class="extype" href="../../io/nio/SeekableFileChannel.html">SeekableFileChannel</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>DefaultFileOps</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#chars" data-isabs="false">
      <a id="chars(Codec):LongTraversable[Char]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">chars</span>
        
        <span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a></span>)</span><span class="result">: <a name="scalax.io.LongTraversable" class="extype" href="../../io/LongTraversable.html">LongTraversable</a>[<span name="scala.Char" class="extype">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The characters in the object.</p><div class="fullcomment"><div class="comment cmt"><p>The characters in the object.</p><p>If the codec is not the same as the source codec (the codec of
the underlying data) then the characters will converted to the
desired codec.
</p></div><dl class="paramcmts block"><dt class="param">codec</dt><dd class="cmt"><p>
         The codec representing the desired encoding of the characters
@return
         an traversable of all the characters
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="../FileOps.html">FileOps</a> → <a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a> → <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#checkAccess" data-isabs="false">
      <a id="checkAccess(AccessMode*):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">checkAccess</span>
        
        <span class="params">(<span name="modes">modes: <a name="scalax.file.Path.AccessModes.AccessMode" class="extype" href="../Path$$AccessModes$$AccessMode.html">AccessMode</a>*</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Check if the referenced file both exists and be accessed with the requested modes
</p><div class="fullcomment"><div class="comment cmt"><p>Check if the referenced file both exists and be accessed with the requested modes
</p></div><dl class="paramcmts block"><dt class="param">modes</dt><dd class="cmt"><p>the modes to check for on the file.  If empty then only existance
       is checked</p></dd><dt>returns</dt><dd class="cmt"><p>true if all modes are available on the file
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#checkAccess" data-isabs="false">
      <a id="checkAccess(String):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">checkAccess</span>
        
        <span class="params">(<span name="modes">modes: String</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Check modes using the rwx characters.</p><div class="fullcomment"><div class="comment cmt"><p>Check modes using the rwx characters.  The string can be from 1-3 characters long and can be r w x in any order.
Spaces are ignored
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#children" data-isabs="false">
      <a id="children[U&gt;:Path, F](F,Traversable[LinkOption])(PathMatcherFactory[F]):PathSet[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">children</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>, <span name="F">F</span>]</span>
        <span class="params">(<span name="filter">filter: F</span>, <span name="options">options: <span name="scala.collection.Traversable" class="extype">Traversable</span>[<a name="scalax.file.LinkOption" class="extype" href="../LinkOption.html">LinkOption</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="factory">factory: <a name="scalax.file.PathMatcherFactory" class="extype" href="../PathMatcherFactory.html">PathMatcherFactory</a>[F]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="../PathSet.html">PathSet</a>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">An iterable over the contents of the directory.</p><div class="fullcomment"><div class="comment cmt"><p>An iterable over the contents of the directory.  This is simply walkTree with depth=1.</p><p>The filter parameter restricts what paths are available through the PathSet.  This is
different from using the filter, filterFold or filterEach methods in PathSet because PathMatchers can be used by
the underlying filesystem natively and can potentially provide dramatically improved performance for
very large directories.</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>
         A filter that restricts what paths are available in the PathSet
         If the filter is a PathMatcher and the underlying filesystem supports the PatchMatcher
         implementation then the maximum performance will be achieved.
         All Paths that are passed to matcher is relative to this Path
         Default is PathMatcher.All
@return
         A managed resource managing a PathSet.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>FileSystem#matcher(String,String)
</p></span>, <span class="cmt"><p>Path.Matching</p></span>, <span class="cmt"><p>Path#walkTree</p></span></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">clone</span>
        
        <span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#compare" data-isabs="false">
      <a id="compare(Path):Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">compare</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Compares this path to the other lexigraphically.</p><div class="fullcomment"><div class="comment cmt"><p>Compares this path to the other lexigraphically.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → Ordered</dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#compareTo" data-isabs="false">
      <a id="compareTo(Path):Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">compareTo</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered → Comparable</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#context" data-isabs="false">
      <a id="context:ResourceContext"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">context</span>
        
        <span class="result">: <a name="scalax.io.ResourceContext" class="extype" href="../../io/ResourceContext.html">ResourceContext</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Get the Resource context that configures how the underlying resource is accessed
</p><div class="fullcomment"><div class="comment cmt"><p>Get the Resource context that configures how the underlying resource is accessed
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the associated ResourceContext
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a> → <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#copyDataTo" data-isabs="false">
      <a id="copyDataTo(Output):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">copyDataTo</span>
        
        <span class="params">(<span name="output">output: <a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Copy all data from this Input object to the Output object
as efficiently as possible.</p><div class="fullcomment"><div class="comment cmt"><p>Copy all data from this Input object to the Output object
as efficiently as possible.</p></div><dl class="paramcmts block"><dt class="param">output</dt><dd class="cmt"><p>output sink to copy the data to
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#copyTo" data-isabs="false">
      <a id="copyTo[P&lt;:Path](P,Boolean,Boolean,Boolean,Int):P"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">copyTo</span>
        <span class="tparams">[<span name="P">P &lt;: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>]</span>
        <span class="params">(<span name="target">target: P</span>, <span name="createParents">createParents: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="copyAttributes">copyAttributes: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="replaceExisting">replaceExisting: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="depth">depth: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: P</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Copy the underlying object if it exists to the target location.</p><div class="fullcomment"><div class="comment cmt"><p> Copy the underlying object if it exists to the target location.
 If the underlying object is a directory it is not copied recursively.
</p></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>
          the target path to copy the filesystem object to.</p></dd><dt class="param">copyAttributes</dt><dd class="cmt"><p>
          if true then copy the File attributes of the object
          as well as the data.  True by default</p></dd><dt class="param">replaceExisting</dt><dd class="cmt"><p>
          if true then replace any existing target object
          unless it is a non-empty directory in which case
          an IOException is thrown.
          False by default
 @return
          the path to the new copy</p></dd><dt class="param">depth</dt><dd class="cmt"><p>
          The depth of the copy if the path is a Directory.
          A depth of 0 means only the current Path is copied
          A depth of 1 means all children are copied as well, etc...
          default is entire tree</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#createDirectory" data-isabs="false">
      <a id="createDirectory(Boolean,Boolean,Iterable[AccessMode],Iterable[scalax.file.attributes.FileAttribute[_]]):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">createDirectory</span>
        
        <span class="params">(<span name="createParents">createParents: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>, <span name="failIfExists">failIfExists: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>, <span name="accessModes">accessModes: Iterable[<a name="scalax.file.Path.AccessModes.AccessMode" class="extype" href="../Path$$AccessModes$$AccessMode.html">AccessMode</a>] = <span class="symbol"><span class="name"><a href="../Path$.html">List(Read,Write,Execute)</a></span></span></span>, <span name="attributes">attributes: Iterable[scalax.file.attributes.FileAttribute[_]] = <span class="symbol">Nil</span></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create the directory referenced by this path.</p><div class="fullcomment"><div class="comment cmt"><p>Create the directory referenced by this path.</p><p>If failIfExists then IOException is thrown if the file already exists.
In the next Java 7 only version it will throw FileAlreadyExistsException</p><p>An exception is always thrown if the file is a directory and that directory
contains children</p><p>An exception will also be thrown if the parent directory does not have write
permission
</p></div><dl class="paramcmts block"><dt class="param">createParents</dt><dd class="cmt"><p>
         If true then the containing directories will be created if they do not exist
         Default is true</p></dd><dt class="param">failIfExists</dt><dd class="cmt"><p>
         If true and an object exists then an exception will be thrown
         If false then the object will be deleted if possible
         If not possible to delete the object or it is a non-empty directory
           an exception will be thrown
         Default is true</p></dd><dt class="param">accessModes</dt><dd class="cmt"><p>
         The access modes that to set on the file
         Default is Read,Write</p></dd><dt class="param">attributes</dt><dd class="cmt"><p>
         Filesystem specific attributes to fromString to the file
         Ignored unless on Java 7+ JVM
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#createFile" data-isabs="false">
      <a id="createFile(Boolean,Boolean,Iterable[AccessMode],Iterable[scalax.file.attributes.FileAttribute[_]]):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">createFile</span>
        
        <span class="params">(<span name="createParents">createParents: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>, <span name="failIfExists">failIfExists: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>, <span name="accessModes">accessModes: Iterable[<a name="scalax.file.Path.AccessModes.AccessMode" class="extype" href="../Path$$AccessModes$$AccessMode.html">AccessMode</a>] = <span class="symbol"><span class="name"><a href="../Path$.html">List(Read,Write)</a></span></span></span>, <span name="attributes">attributes: Iterable[scalax.file.attributes.FileAttribute[_]] = <span class="symbol">Nil</span></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create the file referenced by this path.</p><div class="fullcomment"><div class="comment cmt"><p>Create the file referenced by this path.</p><p>If failIfExists then IOException is thrown if the file already exists.
In the next Java 7 only version it will throw FileAlreadyExistsException</p><p>An exception is always thrown if the file is a directory and that directory
contains children</p><p>An Exception will also be thrown if the parent directory does not have write
permission
</p></div><dl class="paramcmts block"><dt class="param">createParents</dt><dd class="cmt"><p>
         If true then the containing directories will be created if they do not exist
         Default is true</p></dd><dt class="param">failIfExists</dt><dd class="cmt"><p>
         If true and an object exists then an exception will be thrown
         If false then the object will be deleted if possible
         If not possible to delete the object or it is a non-empty directory
           an exception will be thrown
         Default is true</p></dd><dt class="param">accessModes</dt><dd class="cmt"><p>
         The access modes that to set on the file
         Default is Read,Write</p></dd><dt class="param">attributes</dt><dd class="cmt"><p>
         Filesystem specific attributes to fromString to the file
         Ignored unless on Java 7+ JVM</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#delete" data-isabs="false">
      <a id="delete(Boolean):DefaultPath.this.type"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">delete</span>
        
        <span class="params">(<span name="force">force: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: DefaultPath.this.type</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Deletes the file or throws an IOException on failure
</p><div class="fullcomment"><div class="comment cmt"><p>Deletes the file or throws an IOException on failure
</p></div><dl class="paramcmts block"><dt class="param">force</dt><dd class="cmt"><p>
         if the file is write protected force will override
         the write protection and delete the file.  If not
         force then an IOException will be thrown indicating
         failure of deletion.
         Default is false</p></dd><dt>returns</dt><dd class="cmt"><p>this</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#deleteIfExists" data-isabs="false">
      <a id="deleteIfExists(Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">deleteIfExists</span>
        
        <span class="params">(<span name="force">force: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Delete the filesystem object if the file exists.</p><div class="fullcomment"><div class="comment cmt"><p> Delete the filesystem object if the file exists.</p><p> If the file exists and is a non-empty Directory or
 there is some other reason the operation cannot be performed an
 IOException will be thrown.</p><p> If the file does not exist it will return false
</p></div><dl class="paramcmts block"><dt class="param">force</dt><dd class="cmt"><p>
         if the file is write protected force will override
         the write protection and delete the file.  If not
         force then an IOException will be thrown indicating
         failure of deletion.
         Default is false</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#deleteRecursively" data-isabs="false">
      <a id="deleteRecursively(Boolean,Boolean):(Int, Int)"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">deleteRecursively</span>
        
        <span class="params">(<span name="force">force: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>, <span name="continueOnFailure">continueOnFailure: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: (<span name="scala.Int" class="extype">Int</span>, <span name="scala.Int" class="extype">Int</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Deletes the directory recursively.</p><div class="fullcomment"><div class="comment cmt"><p> Deletes the directory recursively.</p><p> This method does not detect circular directory graphs and
 does not promise to perform the delete in an atomic operation</p><p>Use with caution!</p></div><dl class="paramcmts block"><dt class="param">force</dt><dd class="cmt"><p>
         if the file is write protected force will override
         the write protection and delete the file.  If not
         force then an IOException will be thrown indicating
         failure of deletion.
         Default is false</p></dd><dt class="param">continueOnFailure</dt><dd class="cmt"><p>
          If false then method will throw an exception when encountering a
          file that cannot be deleted.  Otherwise it will continue
          to delete all the files that can be deleted.
          Note:  this method is not transactional, all files visited before
          failure are deleted.</p><p> @return
          Tuple with (The number of files deleted, The number of files remaining)</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#descendants" data-isabs="false">
      <a id="descendants[U&gt;:Path, F](F,Int,Traversable[LinkOption])(PathMatcherFactory[F]):BasicPathSet[DefaultPath]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">descendants</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>, <span name="F">F</span>]</span>
        <span class="params">(<span name="filter">filter: F</span>, <span name="depth">depth: <span name="scala.Int" class="extype">Int</span></span>, <span name="options">options: <span name="scala.collection.Traversable" class="extype">Traversable</span>[<a name="scalax.file.LinkOption" class="extype" href="../LinkOption.html">LinkOption</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="factory">factory: <a name="scalax.file.PathMatcherFactory" class="extype" href="../PathMatcherFactory.html">PathMatcherFactory</a>[F]</span>)</span><span class="result">: <a name="scalax.file.BasicPathSet" class="extype" href="../BasicPathSet.html">BasicPathSet</a>[<a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">An iterable that traverses all the elements in the directory tree down to the specified depth</p><div class="fullcomment"><div class="comment cmt"><p>An iterable that traverses all the elements in the directory tree down to the specified depth</p><p>The filter parameter is a function because the PathSet can return files from many directories.
The function provides the mechanism for declaring which PathMatcher to use at each level.  The two
parameters are original path and the path to be visited relative to the original path.  By default the
function always returns None.</p><p>If the depth parameter is non-negative then that restricts the depth that will be traversed.  The value 0 will not return any
elements, depth = 1 is essentially the <code> path#directoryStream(Option,Boolean)</code> method and values &lt; 0 will return all elements
at any depth.</p><p>The traversal order is pre-order.</p><p>No exceptions will be thrown by this method if it is called and the Path is a File or does not exist.  Instead the <code> PathSet</code>
will throw a NotDirectoryException when a method is called and the underlying object is not a Directory.
</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>
         A filter that restricts what paths are available in the PathSet
         If the filter is a PathMatcher and the underlying filesystem supports the PatchMatcher
         implementation then the maximum performance will be achieved.
         All Paths that are passed to matcher is relative to this Path
         Default is PathMatcher.All</p></dd><dt class="param">depth</dt><dd class="cmt"><p>
         How deep down the tree to traverse
         1 is just visit the objects in the directory
         negative values will visit entire tree
         Default is -1</p><p>@return
         A managed resource managing a PathSet.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>FileSystem#matcher(String,String)
</p></span>, <span class="cmt"><p>Path.Matching</p></span>, <span class="cmt"><p>Path#directoryStream(Option,Boolean)</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#doCopyFrom" data-isabs="false">
      <a id="doCopyFrom(Input):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">doCopyFrom</span>
        
        <span class="params">(<span name="input">input: <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If possible efficiently copy data from input.</p><div class="fullcomment"><div class="comment cmt"><p>If possible efficiently copy data from input.  It MUST NOT forward request to
input's copyTo method because that could trigger an infinate loop
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#doCreateDirectory" data-isabs="false">
      <a id="doCreateDirectory():Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">doCreateDirectory</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">NOT PUBLIC API: Create a directory for the current path without considering if the parents
has been previously created.</p><div class="fullcomment"><div class="comment cmt"><p>NOT PUBLIC API: Create a directory for the current path without considering if the parents
has been previously created.   This method should fail if the parent does not exist
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#doCreateFile" data-isabs="false">
      <a id="doCreateFile():Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">doCreateFile</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">NOT PUBLIC API: Create a file for the current path without considering if the parents
has been previously created.</p><div class="fullcomment"><div class="comment cmt"><p>NOT PUBLIC API: Create a file for the current path without considering if the parents
has been previously created.   This method should fail if the parent does not exist
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#doCreateParents" data-isabs="false">
      <a id="doCreateParents():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">doCreateParents</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">NOT PUBLIC API: Create all parent directories of the current Path
</p><div class="fullcomment"><div class="comment cmt"><p>NOT PUBLIC API: Create all parent directories of the current Path
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#endsWith" data-isabs="false">
      <a id="endsWith(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">endsWith</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if this path ends with the other path</p><div class="fullcomment"><div class="comment cmt"><p>True if this path ends with the other path</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if this path ends with the other path
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">eq</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">equals</span>
        
        <span class="params">(<span name="other">other: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#exists" data-isabs="false">
      <a id="exists:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">exists</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the path exists in the file system
</p><div class="fullcomment"><div class="comment cmt"><p>True if the path exists in the file system
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if the path exists in the file system</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#exists
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#extension" data-isabs="false">
      <a id="extension:Option[String]"></a>
      <h4 class="signature">
      <span class="kind">lazy val</span>
      <span class="symbol"> 
        <span class="name">extension</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The extension of the name of the path, if it exists.</p><div class="fullcomment"><div class="comment cmt"><p>The extension of the name of the path, if it exists. if name ends with an
extension (e.g. &quot;foo.jpg&quot;) returns the extension (&quot;jpg&quot;)
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the extension of the path
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultFileOps#fileChannel" data-isabs="false">
      <a id="fileChannel(OpenOption*):Some[SeekableByteChannelResource[SeekableFileChannel]]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">fileChannel</span>
        
        <span class="params">(<span name="openOptions">openOptions: <a name="scalax.io.OpenOption" class="extype" href="../../io/OpenOption.html">OpenOption</a>*</span>)</span><span class="result">: <span name="scala.Some" class="extype">Some</span>[<a name="scalax.io.managed.SeekableByteChannelResource" class="extype" href="../../io/managed/SeekableByteChannelResource.html">SeekableByteChannelResource</a>[<a name="scalax.io.nio.SeekableFileChannel" class="extype" href="../../io/nio/SeekableFileChannel.html">SeekableFileChannel</a>]]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>DefaultFileOps</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#fileOption" data-isabs="false">
      <a id="fileOption:Option[File]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">fileOption</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="java.io.File" class="extype">File</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Return a java.</p><div class="fullcomment"><div class="comment cmt"><p>Return a java.io.File if possible
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#fileSystem" data-isabs="false">
      <a id="fileSystem:DefaultFileSystem"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">fileSystem</span>
        
        <span class="result">: <span name="scalax.file.defaultfs.DefaultFileSystem" class="extype">DefaultFileSystem</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">finalize</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">getClass</span>
        
        <span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">hashCode</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultFileOps#inputStream" data-isabs="false">
      <a id="inputStream:InputStreamResource[FileInputStream]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">inputStream</span>
        
        <span class="result">: <a name="scalax.io.managed.InputStreamResource" class="extype" href="../../io/managed/InputStreamResource.html">InputStreamResource</a>[<span name="java.io.FileInputStream" class="extype">FileInputStream</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>DefaultFileOps</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#insert" data-isabs="false">
      <a id="insert[T](Long,T)(OutputConverter[T]):Any"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">insert</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="data">data: T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="converter">converter: <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a>[T]</span>)</span><span class="result">: <span name="scala.Any" class="extype">Any</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts data at a position in the Seekable.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts data at a position in the Seekable.  The actual position in the Seekable where the data is inserted depends on
the type of data being written.  For example if Longs are being written then position calculated as position * 8</p><p><b>Important:</b> The use of an Array is highly recommended
 because normally arrays can be more efficiently written using
 the underlying APIs
</p></div><dl class="paramcmts block"><dt class="param">position</dt><dd class="cmt"><p>The position where the data is inserted into the Seekable.  The actual position in the Seekable
where the data is inserted depends on the type of data being written.  For example if
Longs are being written then position calculated as position * 8
</p></dd><dt class="param">data</dt><dd class="cmt"><p>
         The data to write.  This can be any type that has a <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> associated
         with it.  There are predefined $outputConverters for several types.  See the
         <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object for the predefined types and for objects to simplify implementing
         custom <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a></p><p>$converterParam
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#insert" data-isabs="false">
      <a id="insert(Long,String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">insert</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="string">string: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts a string at a position in the Seekable.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts a string at a position in the Seekable. This is a potentially inefficient because of the need to
count characters.  If the codec is not a fixed sized codec (for example UTF8) each character must be
converted in the file up to the point of insertion.
</p></div><dl class="paramcmts block"><dt class="param">position</dt><dd class="cmt"><p>The position in the file to perform the insert.  A position of 2 will insert the character after
             the second character (not byte).</p></dd><dt class="param">string</dt><dd class="cmt"><p>The string that will be inserted into the Seekable</p></dd><dt class="param">codec</dt><dd class="cmt"><p>The codec to use for determining the location for inserting the string and for encoding the
             string as bytes
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#insertIntsAsBytes" data-isabs="false">
      <a id="insertIntsAsBytes(Long,Int*):Any"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">insertIntsAsBytes</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="data">data: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <span name="scala.Any" class="extype">Any</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Since the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Since the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.  In other words just taking the first
 byte.  This is pretty common in Java.io style IO.  IE</p><pre>
 outputStream.write(1) 
</pre><p> 1 is written as a single byte.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#isAbsolute" data-isabs="false">
      <a id="isAbsolute:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isAbsolute</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True is the file is absolute.</p><div class="fullcomment"><div class="comment cmt"><p>True is the file is absolute.
IE is rooted at a filesystem root</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if file is absolute.</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#isAbsolute
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#isDirectory" data-isabs="false">
      <a id="isDirectory:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isDirectory</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the path exists and is a directory
</p><div class="fullcomment"><div class="comment cmt"><p>True if the path exists and is a directory
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if the path exists and is a directory</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#isDirectory
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#isFile" data-isabs="false">
      <a id="isFile:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isFile</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the path exists and is a file
</p><div class="fullcomment"><div class="comment cmt"><p>True if the path exists and is a file
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if the path exists and is a file</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#isFile
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isFresher" data-isabs="false">
      <a id="isFresher(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isFresher</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if this path has been modified more recently than other.</p><div class="fullcomment"><div class="comment cmt"><p>True if this path has been modified more recently than other.
If this file does not exist it is not fresh than other
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if this path has been modified more recently than other.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#isHidden" data-isabs="false">
      <a id="isHidden:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isHidden</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the file is a hidden file for the current
filesystem
</p><div class="fullcomment"><div class="comment cmt"><p>True if the file is a hidden file for the current
filesystem
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if the file is a hidden file for the current
filesystem</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#isHidden()
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isSame" data-isabs="false">
      <a id="isSame(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isSame</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if this path and the other path reference the same file.</p><div class="fullcomment"><div class="comment cmt"><p>True if this path and the other path reference the same file.</p><p>This means the two paths may have different segments and perhaps
even have symlinks in the path but if they reference the same file
then this will return true.  Use equals to test if the paths are the same</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if this path and the other path reference the same file.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isSymlink" data-isabs="false">
      <a id="isSymlink:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isSymlink</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the file is a symlink.</p><div class="fullcomment"><div class="comment cmt"><p>True if the file is a symlink.</p><p>This method is generally correct but depending
the filesystem there is a possibility of getting the
the incorrect result since the canonical and absolute
paths are compared and no native code is used.  Future
versions will be guaranteed to work correctly but this version
cannot be because of limitations of the VM.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if the file is a symlink.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#iterator" data-isabs="false">
      <a id="iterator:Iterator[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">iterator</span>
        
        <span class="result">: Iterator[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#jfile" data-isabs="false">
      <a id="jfile:File"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">jfile</span>
        
        <span class="result">: <span name="java.io.File" class="extype">File</span></span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#lastModified" data-isabs="false">
      <a id="lastModified:Long"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">lastModified</span>
        
        <span class="result">: <span name="scala.Long" class="extype">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The time of the last modification of the file
</p><div class="fullcomment"><div class="comment cmt"><p>The time of the last modification of the file
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the time modified or -1 if not applicable for fileSystem</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#getLastModified()
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#lastModified_=" data-isabs="false">
      <a id="lastModified_=(Long):Long"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">lastModified_=</span>
        
        <span class="params">(<span name="time">time: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Long" class="extype">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Set the last time modified of the file
</p><div class="fullcomment"><div class="comment cmt"><p>Set the last time modified of the file
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the new time</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#setLastModified(Long)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Input#lines" data-isabs="false">
      <a id="lines(Terminator,Boolean)(Codec):LongTraversable[String]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">lines</span>
        
        <span class="params">(<span name="terminator">terminator: <a name="scalax.io.Line.Terminators.Terminator" class="extype" href="../../io/Line$$Terminators$$Terminator.html">Terminator</a> = <span class="symbol"><span class="name"><a href="../../io/Line$.html">Terminators.Auto</a></span></span></span>, <span name="includeTerminator">includeTerminator: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <a name="scalax.io.LongTraversable" class="extype" href="../../io/LongTraversable.html">LongTraversable</a>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtain an non-strict traversable for iterating through the lines in the object</p><div class="fullcomment"><div class="comment cmt"><p>Obtain an non-strict traversable for iterating through the lines in the object</p><p>If the codec is not the same as the source codec (the codec of
the underlying data) then the characters will converted to the
desired codec.
</p></div><dl class="paramcmts block"><dt class="param">terminator</dt><dd class="cmt"><p>
         The strategy for determining the end of line
         Default is to auto-detect the EOL</p></dd><dt class="param">includeTerminator</dt><dd class="cmt"><p>
         if true then the line will end with the line terminator
         Default is false</p><p>@return
         a non-strict traversable for iterating through all the lines
</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         The codec representing the desired encoding of the characters</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#matcher" data-isabs="false">
      <a id="matcher(String,String):PathMatcher[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">matcher</span>
        
        <span class="params">(<span name="pattern">pattern: String</span>, <span name="syntax">syntax: String = <span class="symbol"><span class="name"><a href="../PathMatcher$.html">PathMatcher.StandardSyntax.GLOB</a></span></span></span>)</span><span class="result">: <a name="scalax.file.PathMatcher" class="extype" href="../PathMatcher.html">PathMatcher</a>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a matcher from this path's filesystem</p><div class="fullcomment"><div class="comment cmt"><p>Create a matcher from this path's filesystem</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>FileSystem # matcher ( String, String )
</p></span></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.defaultfs.DefaultPath#moveDirectory" data-isabs="false">
      <a id="moveDirectory(Path,Boolean):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">moveDirectory</span>
        
        <span class="params">(<span name="target">target: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>, <span name="atomicMove">atomicMove: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Called to move the current directory to another location <strong>on the same filesystem</strong>
</p><div class="fullcomment"><div class="comment cmt"><p>Called to move the current directory to another location <strong>on the same filesystem</strong>
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.defaultfs.DefaultPath#moveFile" data-isabs="false">
      <a id="moveFile(Path,Boolean):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">moveFile</span>
        
        <span class="params">(<span name="target">target: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>, <span name="atomicMove">atomicMove: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Called to move the current file to another location <strong>on the same filesystem</strong>
</p><div class="fullcomment"><div class="comment cmt"><p>Called to move the current file to another location <strong>on the same filesystem</strong>
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#moveTo" data-isabs="false">
      <a id="moveTo[P&lt;:Path](P,Boolean,Boolean):P"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">moveTo</span>
        <span class="tparams">[<span name="P">P &lt;: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>]</span>
        <span class="params">(<span name="target">target: P</span>, <span name="replace">replace: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="atomicMove">atomicMove: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: P</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Move the underlying object if it exists to the target location.</p><div class="fullcomment"><div class="comment cmt"><p> Move the underlying object if it exists to the target location.</p><p> If copying of the file is required this will happen, as long as
 atomicMove = false.  If atomicMove = true and the move requires copy then
 deletion an exception will be thrown.  This is filesystem dependent</p></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>
          the target path to move the filesystem object to.</p></dd><dt class="param">replace</dt><dd class="cmt"><p>
          if true then replace any existing target object
          unless it is a non-empty directory in which case
          an IOException is thrown.
          False by default</p></dd><dt class="param">atomicMove</dt><dd class="cmt"><p>
          it will guarantee atomicity of the move
          False by default
</p></dd><dt>returns</dt><dd class="cmt"><p>true
          the path to the moved object</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#name" data-isabs="false">
      <a id="name:String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">name</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The name of the file.</p><div class="fullcomment"><div class="comment cmt"><p>The name of the file.  This includes the extension of the file</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the name of the file
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">ne</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#nonExistent" data-isabs="false">
      <a id="nonExistent:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">nonExistent</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> False if the path does not exist in the file system
</p><div class="fullcomment"><div class="comment cmt"><p> False if the path does not exist in the file system
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>false if the path does not exist in the file system
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#normalize" data-isabs="false">
      <a id="normalize:PathType"></a>
      <h4 class="signature">
      <span class="kind">lazy val</span>
      <span class="symbol"> 
        <span class="name">normalize</span>
        
        <span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the related Path that starts at a root of the file system and is the direct
path with all relative segments are resolved.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the related Path that starts at a root of the file system and is the direct
path with all relative segments are resolved.</p><p>For example /home/user/../another is <em>not</em> a valid normalized path.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#toCanonical
</p></span>, <span class="cmt"><p>#toAbsolute</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notify</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notifyAll</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#outputProcessor" data-isabs="false">
      <a id="outputProcessor:OutputProcessor"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">outputProcessor</span>
        
        <span class="result">: <a name="scalax.io.processing.OutputProcessor" class="extype" href="../../io/processing/OutputProcessor.html">OutputProcessor</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the function 'f' passing an Output instance that performs all operations
on a single opened connection to the underlying resource.</p><div class="fullcomment"><div class="comment cmt"><p>Execute the function 'f' passing an Output instance that performs all operations
on a single opened connection to the underlying resource. Typically each call to
one of the Output's methods results in a new connection.  For example if the underlying
OutputStream truncates the file each time the connection is made then calling write
two times will result in the contents of the second write overwriting the second write.</p><p>Even if the underlying resource is an appending, using open will be more efficient since
the connection only needs to be made a single time.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the result of the function
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultFileOps#outputStream" data-isabs="false">
      <a id="outputStream(OpenOption*):OutputStreamResource[FileOutputStream]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">outputStream</span>
        
        <span class="params">(<span name="openOptions">openOptions: <a name="scalax.io.OpenOption" class="extype" href="../../io/OpenOption.html">OpenOption</a>*</span>)</span><span class="result">: <a name="scalax.io.managed.OutputStreamResource" class="extype" href="../../io/managed/OutputStreamResource.html">OutputStreamResource</a>[<span name="java.io.FileOutputStream" class="extype">FileOutputStream</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>DefaultFileOps</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#parent" data-isabs="false">
      <a id="parent:Option[DefaultPath]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">parent</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[<a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The parent path segment if it is possible (for example a root will not have a parent)</p><div class="fullcomment"><div class="comment cmt"><p>The parent path segment if it is possible (for example a root will not have a parent)</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the parent path segment if it possible</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>parents
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#parents" data-isabs="false">
      <a id="parents:Seq[Path]"></a>
      <h4 class="signature">
      <span class="kind">lazy val</span>
      <span class="symbol"> 
        <span class="name">parents</span>
        
        <span class="result">: Seq[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The path segments of the path excluding the current path segment.</p><div class="fullcomment"><div class="comment cmt"><p>The path segments of the path excluding the current path segment.  The first
segment is the first segment in the path.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The path segments of the path excluding the current path segment</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>segments
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#patch" data-isabs="false">
      <a id="patch[T](Long,T,Overwrite)(OutputConverter[T]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">patch</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="data">data: T</span>, <span name="overwrite">overwrite: <a name="scalax.io.Overwrite" class="extype" href="../../io/Overwrite.html">Overwrite</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="converter">converter: <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a>[T]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Update a portion of the file content at
 the declared location.</p><div class="fullcomment"><div class="comment cmt"><p>Update a portion of the file content at
 the declared location. This is the most flexible of the
 random access methods but is also (probably) the trickiest
 to fully understand.  That said it behaves (almost) identical
 to a scala.collection.Seq.patch method, so if you understand that
 you should not have difficulty understanding this method.</p><p><b>Important:</b> The use of an Array is highly recommended
 because normally arrays can be more efficiently written using
 the underlying APIs</p><p>To append data the <code>position must &gt;= size</code></p><p>If the position is within the file but the
<code>position + bytes.length</code>
is beyond the end of the file the file will be enlarged so
that the entire string can fit in the file</p><p>The write begins at the position indicated.  So if position = 0
then the write will begin at the first byte of the file.
</p></div><dl class="paramcmts block"><dt class="param">position</dt><dd class="cmt"><p>
         The start position of the update starting at 0.
         The position must be within the file or == size (for appending)</p></dd><dt class="param">data</dt><dd class="cmt"><p>
         The data to write.  This can be any type that has a <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> associated
         with it.  There are predefined $outputConverters for several types.  See the
         <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object for the predefined types and for objects to simplify implementing
         custom <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a></p></dd><dt class="param">overwrite</dt><dd class="cmt"><p>The strategy that dictates how many characters/bytes/units are overwritten
$converterParam
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#patch" data-isabs="false">
      <a id="patch(Long,String,Overwrite)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">patch</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="string">string: String</span>, <span name="overwrite">overwrite: <a name="scalax.io.Overwrite" class="extype" href="../../io/Overwrite.html">Overwrite</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Update a portion of the file content at
 the declared location.</p><div class="fullcomment"><div class="comment cmt"><p>Update a portion of the file content at
 the declared location. This is the most flexible of the
 random access methods but is also (probably) the trickiest
 to fully understand.  That said it behaves (almost) identical
 to a scala.collection.Seq.patch method, so if you understand that
 you should not have difficulty understanding this method.</p><p>If the position is beyond the end of the file a BufferUnderflow
Exception will be thrown</p><p>If the position is within the file but the
<code>position + string.getBytes(codec).length</code>
is beyond the end of the file the file will be enlarged so
that the entire string can fit in the file</p><p>The write begins at the position indicated.  So if position = 0
then the write will begin at the first byte of the file.
</p></div><dl class="paramcmts block"><dt class="param">position</dt><dd class="cmt"><p>
         The start position of the update starting at 0.
         The position is the position'th character in the file using
         the codec for decoding the file
         The position must be within the file.</p></dd><dt class="param">string</dt><dd class="cmt"><p>
         The string to write to the file starting at
         position.</p></dd><dt class="param">overwrite</dt><dd class="cmt"><p>The strategy that dictates how many characters/bytes/units are overwritten</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         The codec to use for decoding the underlying data into characters
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#patchIntsAsBytes" data-isabs="false">
      <a id="patchIntsAsBytes(Long,Overwrite,Int*):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">patchIntsAsBytes</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="overwrite">overwrite: <a name="scalax.io.Overwrite" class="extype" href="../../io/Overwrite.html">Overwrite</a></span>, <span name="data">data: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Since the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Since the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.  In other words just taking the first
 byte.  This is pretty common in Java.io style IO.  IE</p><pre>
 outputStream.write(1) 
</pre><p> 1 is written as a single byte.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#path" data-isabs="false">
      <a id="path:String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">path</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The path of the file.</p><div class="fullcomment"><div class="comment cmt"><p>The path of the file.  It may or may not be relative
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the path of the file
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.io.Seekable#readWriteChannel" data-isabs="false">
      <a id="readWriteChannel[U]((SeekableByteChannel) ⇒ U):U"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">readWriteChannel</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (<a name="scalax.io.SeekableByteChannel" class="extype" href="../../io/SeekableByteChannel.html">SeekableByteChannel</a>) ⇒ U</span>)</span><span class="result">: U</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#relativize" data-isabs="false">
      <a id="relativize(Path):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">relativize</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Make the current path relative to the other path.</p><div class="fullcomment"><div class="comment cmt"><p>Make the current path relative to the other path.  If the two paths
are on different drives then the other path is returned. If the two
paths have different roots the other path is returned.  If the two paths
reference the same path then the other path is returned</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>relative path from the current path to the other path
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#resolve" data-isabs="false">
      <a id="resolve(String*):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">resolve</span>
        
        <span class="params">(<span name="pathSegments">pathSegments: String*</span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Constructs a path from other using the same file system as this
path and resolves the this and other in the same manner as
<code> Path#resolve(Path)</code></p><div class="fullcomment"><div class="comment cmt"><p>Constructs a path from other using the same file system as this
path and resolves the this and other in the same manner as
<code> Path#resolve(Path)</code></p><p>Examples:</p><pre>
path resolve (&quot;a/b/c&quot;,'/') // result is Path / a / b / c
path resolve (&quot;//..//b//&quot;,'/') // result is Path / .. / b
</pre></div><dl class="paramcmts block"><dt class="param">pathSegments</dt><dd class="cmt"><p>the path segments that make up the path</p></dd><dt>returns</dt><dd class="cmt"><p>a path resolved as a child of this
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#resolve" data-isabs="false">
      <a id="resolve(String,Char):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">resolve</span>
        
        <span class="params">(<span name="other">other: String</span>, <span name="separator">separator: <span name="scala.Char" class="extype">Char</span></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Constructs a path from other using the same file system as this
path and resolves the this and other in the same manner as
<code> Path#resolve(Path)</code></p><div class="fullcomment"><div class="comment cmt"><p>Constructs a path from other using the same file system as this
path and resolves the this and other in the same manner as
<code> Path#resolve(Path)</code></p><p>Examples:</p><pre>
path resolve (&quot;a/b/c&quot;,'/') // result is Path / a / b / c
path resolve (&quot;//..//b//&quot;,'/') // result is Path / .. / b
</pre></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>the string representation of the path with segment separators as indicated by separator</p></dd><dt class="param">separator</dt><dd class="cmt"><p>the separator character used in other</p></dd><dt>returns</dt><dd class="cmt"><p>a path resolved as a child of this
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#resolve" data-isabs="false">
      <a id="resolve(Path):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">resolve</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Resolve this path with other.</p><div class="fullcomment"><div class="comment cmt"><p>Resolve this path with other.  In the simplest case
that means appending other to this.</p><p> Does the same thing as the / method
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>
         another path to append to this path
@return
         the constructed/resolved path</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#root" data-isabs="false">
      <a id="root:Option[PathType]"></a>
      <h4 class="signature">
      <span class="kind">lazy val</span>
      <span class="symbol"> 
        <span class="name">root</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[PathType]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The root of the file system of the path if it can be determined.</p><div class="fullcomment"><div class="comment cmt"><p>The root of the file system of the path if it can be determined.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the root of the file system
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#seekableProcessor" data-isabs="false">
      <a id="seekableProcessor(Seq[OpenOption],ResourceContext):SeekableProcessor"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">seekableProcessor</span>
        
        <span class="params">(<span name="openOptions">openOptions: Seq[<a name="scalax.io.OpenOption" class="extype" href="../../io/OpenOption.html">OpenOption</a>] = <span class="symbol"><span class="name"><a href="../../package.html">List(Read,Write)</a></span></span></span>, <span name="context">context: <a name="scalax.io.ResourceContext" class="extype" href="../../io/ResourceContext.html">ResourceContext</a> = <span class="symbol"><span class="name"><a href="../Path.html#fileSystem:FileSystem">fileSystem.context</a></span></span></span>)</span><span class="result">: <a name="scalax.io.processing.SeekableProcessor" class="extype" href="../../io/processing/SeekableProcessor.html">SeekableProcessor</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Runs several operations as efficiently as possible.</p><div class="fullcomment"><div class="comment cmt"><p>Runs several operations as efficiently as possible. If the filesystem
permits random access then the same channel will be used to perform all operations.</p><p>Note: only the direct file operations (bytes,lines,write,patch etc...)
can be used and expected to use the same resource. The resource methods
all created new streams.</p><p>Note: not all file systems support this, if not then at worst the performance
is the same as if they where performed outside an open block</p></div><dl class="paramcmts block"><dt class="param">openOptions</dt><dd class="cmt"><p>
         The options that define how the file is opened for the duration of the
         operation
         Default is Write/Create/Truncate</p></dd><dt class="param">context</dt><dd class="cmt"><p>
         The context for controlling buffer sizes error handling and other low level configuration
         defaults to filesystem Resource context
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="../FileOps.html">FileOps</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#seekableProcessor" data-isabs="false">
      <a id="seekableProcessor:SeekableProcessor"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">seekableProcessor</span>
        
        <span class="result">: <a name="scalax.io.processing.SeekableProcessor" class="extype" href="../../io/processing/SeekableProcessor.html">SeekableProcessor</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#segments" data-isabs="false">
      <a id="segments:Seq[String]"></a>
      <h4 class="signature">
      <span class="kind">lazy val</span>
      <span class="symbol"> 
        <span class="name">segments</span>
        
        <span class="result">: Seq[String]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#separator" data-isabs="false">
      <a id="separator:String"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">separator</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The path segment separator string for
the filesystem
</p><div class="fullcomment"><div class="comment cmt"><p>The path segment separator string for
the filesystem
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>FileSystem#separator
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#sibling" data-isabs="false">
      <a id="sibling(String*):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">sibling</span>
        
        <span class="params">(<span name="pathSegments">pathSegments: String*</span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Resolves other against this path's parent in the same manner as sibling(Path)
</p><div class="fullcomment"><div class="comment cmt"><p>Resolves other against this path's parent in the same manner as sibling(Path)
</p></div><dl class="paramcmts block"><dt class="param">pathSegments</dt><dd class="cmt"><p>the path from parent to the sibling.</p></dd><dt>returns</dt><dd class="cmt"><p>a path resolved as a child of parent or other if there is no parent
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#sibling" data-isabs="false">
      <a id="sibling(String,Char):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">sibling</span>
        
        <span class="params">(<span name="other">other: String</span>, <span name="separator">separator: <span name="scala.Char" class="extype">Char</span></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Resolves other against this path's parent in the same manner as sibling(Path)
</p><div class="fullcomment"><div class="comment cmt"><p>Resolves other against this path's parent in the same manner as sibling(Path)
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>the path from parent to the sibling.</p></dd><dt class="param">separator</dt><dd class="cmt"><p>the separator character that is used in other</p></dd><dt>returns</dt><dd class="cmt"><p>a path resolved as a child of parent or other if there is no parent
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#sibling" data-isabs="false">
      <a id="sibling(Path):PathType"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">sibling</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: PathType</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Resolves other against this path's parent in the same manner as in resolve(Path).</p><div class="fullcomment"><div class="comment cmt"><p>Resolves other against this path's parent in the same manner as in resolve(Path).</p><p>If parent does not exist fileSystem.fromSeq(other.segments) will be returned.  Otherwise parent.resolve(other) will be returned
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>the path from parent to the sibling.</p></dd><dt>returns</dt><dd class="cmt"><p>a path resolved as a child of parent or None if parent is None
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#simpleName" data-isabs="false">
      <a id="simpleName:String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">simpleName</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The name of the file excluding of the file</p><div class="fullcomment"><div class="comment cmt"><p>The name of the file excluding of the file</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>name of the file excluding of the file
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#size" data-isabs="false">
      <a id="size:Option[Long]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">size</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Long" class="extype">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The size of the file/directory in bytes
</p><div class="fullcomment"><div class="comment cmt"><p>The size of the file/directory in bytes
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The size of the file/directory in bytes</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#length()
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#startsWith" data-isabs="false">
      <a id="startsWith(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">startsWith</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if this path starts with the other path</p><div class="fullcomment"><div class="comment cmt"><p>True if this path starts with the other path</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if this path starts with the other path
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Input#string" data-isabs="false">
      <a id="string(Codec):String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">string</span>
        
        <span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads all the characters into memory.</p><div class="fullcomment"><div class="comment cmt"><p>Loads all the characters into memory. There is no protection against
loading very large files/amounts of data.
</p></div><dl class="paramcmts block"><dt class="param">codec</dt><dd class="cmt"><p>
         The codec representing the desired encoding of the characters
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">synchronized</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#tempFile" data-isabs="false">
      <a id="tempFile():Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">tempFile</span>
        
        <span class="params">()</span><span class="result">: <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a temporary file to use for performing certain operations.</p><div class="fullcomment"><div class="comment cmt"><p>Create a temporary file to use for performing certain operations.  It should
be as efficient as possible to copy from the temporary file to this Seekable and
vice-versa.  Can be overridden for performance
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → <a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#toAbsolute" data-isabs="false">
      <a id="toAbsolute:DefaultPath"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toAbsolute</span>
        
        <span class="result">: <a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Modifies the Path so that it is absolute from a root of the file system.</p><div class="fullcomment"><div class="comment cmt"><p>Modifies the Path so that it is absolute from a root of the file system.
However it is not necessarily canonical.  For example /home/user/../another
is a valid absolute path.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>normalize
</p></span></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.FileOps#toByteChannelResource" data-isabs="false">
      <a id="toByteChannelResource():InputResource[ByteChannel]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toByteChannelResource</span>
        
        <span class="params">()</span><span class="result">: <a name="scalax.io.InputResource" class="extype" href="../../io/InputResource.html">InputResource</a>[<span name="java.nio.channels.ByteChannel" class="extype">ByteChannel</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Open a seekableByteChannelResource to use for creating other long traversables like chars or bytes as its.</p><div class="fullcomment"><div class="comment cmt"><p>Open a seekableByteChannelResource to use for creating other long traversables like chars or bytes as its.</p><p>This method may throw an exception if the file does not exist</p><p>Main feature is it sets position to 0 each call so the resource will always read from 0
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="../FileOps.html">FileOps</a> → <a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#toRealPath" data-isabs="false">
      <a id="toRealPath(LinkOption*):DefaultPath"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toRealPath</span>
        
        <span class="params">(<span name="linkOptions">linkOptions: <a name="scalax.file.LinkOption" class="extype" href="../LinkOption.html">LinkOption</a>*</span>)</span><span class="result">: <a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The true/real representation of the current path.</p><div class="fullcomment"><div class="comment cmt"><p>The true/real representation of the current path.</p><p>The full and true path of this path will be resolved, links will be handled according to the link options
. and .. etc... will be resolved and if this path is relative it will be made absolute.</p><p>If no linkOptions are supplied this method will follow links
</p></div><dl class="paramcmts block"><dt class="param">linkOptions</dt><dd class="cmt"><p>How to handle link options
</p></dd><dt>returns</dt><dd class="cmt"><p>the <i>real</i> path
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toString</span>
        
        <span class="params">()</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultPath#toURI" data-isabs="false">
      <a id="toURI:URI"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toURI</span>
        
        <span class="result">: <span name="java.net.URI" class="extype">URI</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a URI from the path.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a URI from the path.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="">DefaultPath</a> → <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#toURI
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#toURL" data-isabs="false">
      <a id="toURL:URL"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toURL</span>
        
        <span class="result">: <span name="java.net.URL" class="extype">URL</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a URL from the path.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a URL from the path.  This does have the bug present in <code> java.file.File#toURL</code>
and can be used directly.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#toURI
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#truncate" data-isabs="false">
      <a id="truncate(Long):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">truncate</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Truncate/Chop the Seekable to the number of bytes declared by the position param
</p><div class="fullcomment"><div class="comment cmt"><p>Truncate/Chop the Seekable to the number of bytes declared by the position param
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#truncateString" data-isabs="false">
      <a id="truncateString(Long)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">truncateString</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.FileOps#underlyingChannel" data-isabs="false">
      <a id="underlyingChannel(Boolean):OpenedResource[SeekableByteChannel]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">underlyingChannel</span>
        
        <span class="params">(<span name="append">append: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="scalax.io.OpenedResource" class="extype" href="../../io/OpenedResource.html">OpenedResource</a>[<a name="scalax.io.SeekableByteChannel" class="extype" href="../../io/SeekableByteChannel.html">SeekableByteChannel</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="../FileOps.html">FileOps</a> → <a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.FileOps#underlyingOutput" data-isabs="false">
      <a id="underlyingOutput:OutputResource[WritableByteChannel]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">underlyingOutput</span>
        
        <span class="result">: <a name="scalax.io.OutputResource" class="extype" href="../../io/OutputResource.html">OutputResource</a>[<span name="java.nio.channels.WritableByteChannel" class="extype">WritableByteChannel</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="../FileOps.html">FileOps</a> → <a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a> → <a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.defaultfs.DefaultFileOps#withLock" data-isabs="false">
      <a id="withLock[R](Long,Long,Boolean,ResourceContext)((Seekable) ⇒ R):Option[R]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">withLock</span>
        <span class="tparams">[<span name="R">R</span>]</span>
        <span class="params">(<span name="start">start: <span name="scala.Long" class="extype">Long</span> = <span class="symbol">0</span></span>, <span name="size">size: <span name="scala.Long" class="extype">Long</span> = <span class="symbol">1</span></span>, <span name="shared">shared: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>, <span name="context">context: <a name="scalax.io.ResourceContext" class="extype" href="../../io/ResourceContext.html">ResourceContext</a></span>)</span><span class="params">(<span name="block">block: (<a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a>) ⇒ R</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[R]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>DefaultFileOps</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#write" data-isabs="false">
      <a id="write(String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">write</span>
        
        <span class="params">(<span name="string">string: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Writes a string.</p><div class="fullcomment"><div class="comment cmt"><p>Writes a string.
</p></div><dl class="paramcmts block"><dt class="param">string</dt><dd class="cmt"><p>
         the data to write</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         the codec of the string to be written. The string will
         be converted to the encoding of <code> sourceCodec</code>
         Default is sourceCodec
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#write" data-isabs="false">
      <a id="write[T](T)(OutputConverter[T]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">write</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="data">data: T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="writer">writer: <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a>[T]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Write data to the underlying object.</p><div class="fullcomment"><div class="comment cmt"><p>Write data to the underlying object.  Each time write is called the resource is reopened, in the case of a
file this means that the file will be opened and truncated.  The</p><p>In the case of writing ints and bytes it is often
recommended to write arrays of data since normally the underlying object can write arrays
of bytes or integers most efficiently.</p><p>Since Characters require a codec to write to an OutputStream characters cannot be written with this method
unless a OutputWriterFunction.CharFunction object is provided as the writer.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>
         The data to write to underlying object.  Any data that has a resolvable <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> can
         be written.  See the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object for the defined <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a>
         implementations and classes to assist implementing more.</p></dd><dt class="param">writer</dt><dd class="cmt"><p>
         The strategy used to write the data to the underlying object.  Many standard data-types are implicitly
         resolved and do not need to be supplied
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></dd><dt>See also</dt><dd><span class="cmt"><p>#writeChars for more on writing characters
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#writeChars" data-isabs="false">
      <a id="writeChars(TraversableOnce[Char])(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">writeChars</span>
        
        <span class="params">(<span name="characters">characters: TraversableOnce[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#writeIntsAsBytes" data-isabs="false">
      <a id="writeIntsAsBytes(Int*):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">writeIntsAsBytes</span>
        
        <span class="params">(<span name="data">data: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Since the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
is provided to simply write an array of Ints as if they are Bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Since the <a name="scalax.io.OutputConverter" class="extype" href="../../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
is provided to simply write an array of Ints as if they are Bytes.  In other words just taking the first
byte.  This is pretty common in Java.io style IO.  IE</p><pre>
 outputStream.write(1) 
</pre><p>1 is written as a single byte.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#writeStrings" data-isabs="false">
      <a id="writeStrings(Traversable[String],String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">writeStrings</span>
        
        <span class="params">(<span name="strings">strings: <span name="scala.collection.Traversable" class="extype">Traversable</span>[String]</span>, <span name="separator">separator: String = <span class="symbol">&quot;&quot;</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Write several strings.</p><div class="fullcomment"><div class="comment cmt"><p>Write several strings.
</p></div><dl class="paramcmts block"><dt class="param">strings</dt><dd class="cmt"><p>
         The data to write</p></dd><dt class="param">separator</dt><dd class="cmt"><p>
         A string to add between each string.
         It is not added to the before the first string
         or after the last.</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         The codec of the strings to be written. The strings will
         be converted to the encoding of <code> sourceCodec</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></dd></dl></div>
    </li></ol>
            </div>

        

        <div name="scalax.file.defaultfs.DefaultFileOps" class="parent">
              <h3>Inherited from <span name="scalax.file.defaultfs.DefaultFileOps" class="extype">DefaultFileOps</span></h3>
            </div><div name="scalax.file.Path" class="parent">
              <h3>Inherited from <a name="scalax.file.Path" class="extype" href="../Path.html">Path</a></h3>
            </div><div name="scala.math.Ordered" class="parent">
              <h3>Inherited from <span name="scala.math.Ordered" class="extype">Ordered</span>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</h3>
            </div><div name="java.lang.Comparable" class="parent">
              <h3>Inherited from <span name="java.lang.Comparable" class="extype">Comparable</span>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</h3>
            </div><div name="scalax.file.PathFinder" class="parent">
              <h3>Inherited from <a name="scalax.file.PathFinder" class="extype" href="../PathFinder.html">PathFinder</a>[<a name="scalax.file.Path" class="extype" href="../Path.html">Path</a>]</h3>
            </div><div name="scalax.file.FileOps" class="parent">
              <h3>Inherited from <a name="scalax.file.FileOps" class="extype" href="../FileOps.html">FileOps</a></h3>
            </div><div name="scalax.io.Seekable" class="parent">
              <h3>Inherited from <a name="scalax.io.Seekable" class="extype" href="../../io/Seekable.html">Seekable</a></h3>
            </div><div name="scalax.io.Output" class="parent">
              <h3>Inherited from <a name="scalax.io.Output" class="extype" href="../../io/Output.html">Output</a></h3>
            </div><div name="scalax.io.Input" class="parent">
              <h3>Inherited from <a name="scalax.io.Input" class="extype" href="../../io/Input.html">Input</a></h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>

      </div>
      
      <div id="tooltip"></div>
      
    </body>
      </html>