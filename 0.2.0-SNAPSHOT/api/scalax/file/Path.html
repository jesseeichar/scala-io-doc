<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>scalax.file.Path</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../lib/template.css" />
      <script type="text/javascript" src="../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../lib/template.js"></script>
      <script type="text/javascript" src="../../lib/tools.tooltip.js"></script>
    
        </head>
        <body class="type">
      <div id="definition">
        <a title="Go to companion" href="Path$.html"><img src="../../lib/class_to_object_big.png" /></a>
        <p id="owner"><a name="scalax" class="extype" href="../package.html">scalax</a>.<a name="scalax.file" class="extype" href="package.html">file</a></p>
        <h1><a title="Go to companion" href="Path$.html">Path</a></h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="kind">class</span>
      <span class="symbol"> 
        <span class="name">Path</span>
        
        <span class="result"> extends <a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a> with <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a>[<a name="scalax.file.Path" class="extype" href="">Path</a>] with Ordered[<a name="scalax.file.Path" class="extype" href="">Path</a>]</span>
      </span>
      </h4>
      
          <div class="fullcommenttop" id="comment"><div class="comment cmt"><p> A file reference that locates a file using a system independent path.
 The file is not required to exist.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Self Type</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a></dd><dt>Since</dt><dd><p>0.1</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span name="scala.math.Ordered" class="extype">Ordered</span>[<a name="scalax.file.Path" class="extype" href="">Path</a>], <span name="java.lang.Comparable" class="extype">Comparable</span>[<a name="scalax.file.Path" class="extype" href="">Path</a>], <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a>[<a name="scalax.file.Path" class="extype" href="">Path</a>], <a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a>, <a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a>, <a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a>, <a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a>, AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div><div class="toggleContainer block">
          <span class="toggle">Known Subclasses</span>
          <div class="subClasses hiddenContent"><a name="scalax.file.defaultfs.DefaultPath" class="extype" href="defaultfs/DefaultPath.html">DefaultPath</a>, <a name="scalax.file.ramfs.RamPath" class="extype" href="ramfs/RamPath.html">RamPath</a></div>
        </div></div>
        

      <div id="template">

        <div id="mbrsel">
          <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
          <div id="order">
                <span class="filtertype">Ordering</span>
                <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
              </div>
          <div id="ancestors">
                <span class="filtertype">Inherited</span>
                <ol><li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show all</span></li></ol>
                <ol id="linearization"><li name="scalax.file.Path" class="in"><span>Path</span></li><li name="scala.math.Ordered" class="in"><span>Ordered</span></li><li name="java.lang.Comparable" class="in"><span>Comparable</span></li><li name="scalax.file.PathFinder" class="in"><span>PathFinder</span></li><li name="scalax.file.FileOps" class="in"><span>FileOps</span></li><li name="scalax.io.Seekable" class="in"><span>Seekable</span></li><li name="scalax.io.Output" class="in"><span>Output</span></li><li name="scalax.io.Input" class="in"><span>Input</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
              </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>

        <div class="members" id="constructors">
              <h3>Instance Constructors</h3>
              <ol><li visbl="pub" name="scalax.file.Path#this" data-isabs="false">
      <a id="this:Path"></a>
      <h4 class="signature">
      <span class="kind">new</span>
      <span class="symbol"> 
        <span class="name">Path</span>
        
        <span class="params">(<span name="fileSystem">fileSystem: <a name="scalax.file.FileSystem" class="extype" href="FileSystem.html">FileSystem</a></span>)</span>
      </span>
      </h4>
      
    </li></ol>
            </div>

        <div class="types members" id="types">
              <h3>Type Members</h3>
              <ol><li visbl="pub" name="scalax.io.Seekable#OpenSeekable" data-isabs="false">
      <a id="OpenSeekable:OpenSeekable"></a>
      <h4 class="signature">
      <span class="kind">type</span>
      <span class="symbol"> 
        <span class="name">OpenSeekable</span>
        
        <span class="result"> = <a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a> { ... /* 2 definitions in type refinement */ }</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li></ol>
            </div>
        
        <div class="values members" id="values">
              <h3>Abstract Value Members</h3>
              <ol><li visbl="pub" name="scalax.file.Path#/" data-isabs="true">
      <a id="/(String):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">/</span>
        
        <span class="params">(<span name="child">child: String</span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">If child is relative, creates a new Path based on the current path with the
child appended.</p><div class="fullcomment"><div class="comment cmt"><p>If child is relative, creates a new Path based on the current path with the
child appended. If child is absolute the child is returned</p><ul><li>if other is null return this</li><li>if other is absolute return other</li><li>if other is not absolute the return this append other</li></ul><p>Examples include:
<pre>
<code>
path / "child" / "grandchild"
path / "child/grandchild"
path / ".." / "sibling"
path / "../sibling"
</code>
</pre></p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A new path with the specified path appended
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a></dd><dt>See also</dt><dd><span class="cmt"><p>#\(String)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#access_=" data-isabs="true">
      <a id="access_=(Iterable[AccessMode]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">access_=</span>
        
        <span class="params">(<span name="accessModes">accessModes: Iterable[<a name="scalax.file.Path.AccessModes.AccessMode" class="extype" href="Path$$AccessModes$$AccessMode.html">AccessMode</a>]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Sets the standard access modes on the underlying path.</p><div class="fullcomment"><div class="comment cmt"><p>Sets the standard access modes on the underlying path.  If the
underlying object does not exist it will throw an exception.
If the underlying system does not support support the mode the mode
will be ignored
</p></div><dl class="paramcmts block"><dt class="param">accessModes</dt><dd class="cmt"><p>
         the modes to set on the file in (if possible)
         a single atomic update
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#channel" data-isabs="true">
      <a id="channel(OpenOption*):SeekableByteChannelResource[SeekableByteChannel]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">channel</span>
        
        <span class="params">(<span name="openOptions">openOptions: <a name="scalax.io.OpenOption" class="extype" href="../io/OpenOption.html">OpenOption</a>*</span>)</span><span class="result">: <a name="scalax.io.SeekableByteChannelResource" class="extype" href="../io/SeekableByteChannelResource.html">SeekableByteChannelResource</a>[<a name="scalax.io.SeekableByteChannel" class="extype" href="../io/SeekableByteChannel.html">SeekableByteChannel</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtains a ByteChannel for read/write access to the file.</p><div class="fullcomment"><div class="comment cmt"><p>Obtains a ByteChannel for read/write access to the file.  If no OpenOptions are
specified the underlying file will be opened with read/write/create/truncate options</p><p>All <code> OpenOption</code> can be used
</p></div><dl class="paramcmts block"><dt class="param">openOptions</dt><dd class="cmt"><p>
          the options that define how the file is opened when using the stream
          Default is options only
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#checkAccess" data-isabs="true">
      <a id="checkAccess(AccessMode*):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">checkAccess</span>
        
        <span class="params">(<span name="modes">modes: <a name="scalax.file.Path.AccessModes.AccessMode" class="extype" href="Path$$AccessModes$$AccessMode.html">AccessMode</a>*</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Check if the referenced file both exists and be accessed with the requested modes
</p><div class="fullcomment"><div class="comment cmt"><p>Check if the referenced file both exists and be accessed with the requested modes
</p></div><dl class="paramcmts block"><dt class="param">modes</dt><dd class="cmt"><p>the modes to check for on the file.  If empty then only existance
       is checked</p></dd><dt>returns</dt><dd class="cmt"><p>true if all modes are available on the file
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#copyFile" data-isabs="true">
      <a id="copyFile(Path):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">copyFile</span>
        
        <span class="params">(<span name="dest">dest: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Copy a the contents of a Path representing a file to a new destination
a check has been performed that the file exists, so barring a race condition with
another thread or process this path does exist and is a file.</p><div class="fullcomment"><div class="comment cmt"><p>Copy a the contents of a Path representing a file to a new destination
a check has been performed that the file exists, so barring a race condition with
another thread or process this path does exist and is a file.
Dest will not exist at the time of this call.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected abstract </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#delete" data-isabs="true">
      <a id="delete(Boolean):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">delete</span>
        
        <span class="params">(<span name="force">force: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Deletes the file or throws an IOException on failure
</p><div class="fullcomment"><div class="comment cmt"><p>Deletes the file or throws an IOException on failure
</p></div><dl class="paramcmts block"><dt class="param">force</dt><dd class="cmt"><p>
         if the file is write protected force will override
         the write protection and delete the file.  If not
         force then an IOException will be thrown indicating
         failure of deletion.
         Default is false</p></dd><dt>returns</dt><dd class="cmt"><p>this</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#descendants" data-isabs="true">
      <a id="descendants[U&gt;:Path, F](F,Int,Traversable[LinkOption])(PathMatcherFactory[F]):PathSet[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">descendants</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>, <span name="F">F</span>]</span>
        <span class="params">(<span name="filter">filter: F</span>, <span name="depth">depth: <span name="scala.Int" class="extype">Int</span></span>, <span name="options">options: <span name="scala.collection.Traversable" class="extype">Traversable</span>[<a name="scalax.file.LinkOption" class="extype" href="LinkOption.html">LinkOption</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="factory">factory: <a name="scalax.file.PathMatcherFactory" class="extype" href="PathMatcherFactory.html">PathMatcherFactory</a>[F]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="PathSet.html">PathSet</a>[<a name="scalax.file.Path" class="extype" href="">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">An iterable that traverses all the elements in the directory tree down to the specified depth</p><div class="fullcomment"><div class="comment cmt"><p>An iterable that traverses all the elements in the directory tree down to the specified depth</p><p>The filter parameter is a function because the PathSet can return files from many directories.
The function provides the mechanism for declaring which PathMatcher to use at each level.  The two
parameters are original path and the path to be visited relative to the original path.  By default the
function always returns None.</p><p>If the depth parameter is non-negative then that restricts the depth that will be traversed.  The value 0 will not return any
elements, depth = 1 is essentially the <code> path#directoryStream(Option,Boolean)</code> method and values &lt; 0 will return all elements
at any depth.</p><p>The traversal order is pre-order.</p><p>No exceptions will be thrown by this method if it is called and the Path is a File or does not exist.  Instead the <code> PathSet</code>
will throw a NotDirectoryException when a method is called and the underlying object is not a Directory.
</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>
         A filter that restricts what paths are available in the PathSet
         If the filter is a PathMatcher and the underlying filesystem supports the PatchMatcher
         implementation then the maximum performance will be achieved.
         All Paths that are passed to matcher is relative to this Path
         Default is PathMatcher.All</p></dd><dt class="param">depth</dt><dd class="cmt"><p>
         How deep down the tree to traverse
         1 is just visit the objects in the directory
         negative values will visit entire tree
         Default is -1</p><p>@return
         A managed resource managing a PathSet.
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>FileSystem#matcher(String,String)
</p></span>, <span class="cmt"><p>Path.Matching</p></span>, <span class="cmt"><p>Path#directoryStream(Option,Boolean)</p></span></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#doCreateDirectory" data-isabs="true">
      <a id="doCreateDirectory():Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">doCreateDirectory</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">NOT PUBLIC API: Create a directory for the current path without considering if the parents
has been previously created.</p><div class="fullcomment"><div class="comment cmt"><p>NOT PUBLIC API: Create a directory for the current path without considering if the parents
has been previously created.   This method should fail if the parent does not exist
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected abstract </dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#doCreateFile" data-isabs="true">
      <a id="doCreateFile():Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">doCreateFile</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">NOT PUBLIC API: Create a file for the current path without considering if the parents
has been previously created.</p><div class="fullcomment"><div class="comment cmt"><p>NOT PUBLIC API: Create a file for the current path without considering if the parents
has been previously created.   This method should fail if the parent does not exist
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected abstract </dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#doCreateParents" data-isabs="true">
      <a id="doCreateParents():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">doCreateParents</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">NOT PUBLIC API: Create all parent directories of the current Path
</p><div class="fullcomment"><div class="comment cmt"><p>NOT PUBLIC API: Create all parent directories of the current Path
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected abstract </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#exists" data-isabs="true">
      <a id="exists:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">exists</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the path exists in the file system
</p><div class="fullcomment"><div class="comment cmt"><p>True if the path exists in the file system
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if the path exists in the file system</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#exists
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#fileChannel" data-isabs="true">
      <a id="fileChannel(OpenOption*):Option[SeekableByteChannelResource[SeekableByteChannel]]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">fileChannel</span>
        
        <span class="params">(<span name="openOptions">openOptions: <a name="scalax.io.OpenOption" class="extype" href="../io/OpenOption.html">OpenOption</a>*</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<a name="scalax.io.SeekableByteChannelResource" class="extype" href="../io/SeekableByteChannelResource.html">SeekableByteChannelResource</a>[<a name="scalax.io.SeekableByteChannel" class="extype" href="../io/SeekableByteChannel.html">SeekableByteChannel</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtains a FileChannel for read/write access to the file.</p><div class="fullcomment"><div class="comment cmt"><p>Obtains a FileChannel for read/write access to the file.  Not all filesystems
can support FileChannels therefore None will be returned if the filesystem
does not support FileChannels.
If no OpenOptions are specified the underlying file will be
opened with read/write/create/truncate options</p><p>All <code> OpenOption</code> can be used
</p></div><dl class="paramcmts block"><dt class="param">openOptions</dt><dd class="cmt"><p>
         the options that define how the file is opened when using the stream
         Default is read/write/create/truncate
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#inputStream" data-isabs="true">
      <a id="inputStream():InputStreamResource[InputStream]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">inputStream</span>
        
        <span class="params">()</span><span class="result">: <a name="scalax.io.InputStreamResource" class="extype" href="../io/InputStreamResource.html">InputStreamResource</a>[<span name="java.io.InputStream" class="extype">InputStream</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtains an input stream resource for reading from the file
</p><div class="fullcomment"><div class="comment cmt"><p>Obtains an input stream resource for reading from the file
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isAbsolute" data-isabs="true">
      <a id="isAbsolute:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isAbsolute</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True is the file is absolute.</p><div class="fullcomment"><div class="comment cmt"><p>True is the file is absolute.
IE is rooted at a filesystem root</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if file is absolute.</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#isAbsolute
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isDirectory" data-isabs="true">
      <a id="isDirectory:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isDirectory</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the path exists and is a directory
</p><div class="fullcomment"><div class="comment cmt"><p>True if the path exists and is a directory
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if the path exists and is a directory</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#isDirectory
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isFile" data-isabs="true">
      <a id="isFile:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isFile</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the path exists and is a file
</p><div class="fullcomment"><div class="comment cmt"><p>True if the path exists and is a file
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>true if the path exists and is a file</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#isFile
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isHidden" data-isabs="true">
      <a id="isHidden:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isHidden</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the file is a hidden file for the current
filesystem
</p><div class="fullcomment"><div class="comment cmt"><p>True if the file is a hidden file for the current
filesystem
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if the file is a hidden file for the current
filesystem</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#isHidden()
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#lastModified" data-isabs="true">
      <a id="lastModified:Long"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">lastModified</span>
        
        <span class="result">: <span name="scala.Long" class="extype">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">The time of the last modification of the file
</p><div class="fullcomment"><div class="comment cmt"><p>The time of the last modification of the file
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the time modified or -1 if not applicable for fileSystem</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#getLastModified()
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#lastModified_=" data-isabs="true">
      <a id="lastModified_=(Long):Long"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">lastModified_=</span>
        
        <span class="params">(<span name="time">time: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Long" class="extype">Long</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Set the last time modified of the file
</p><div class="fullcomment"><div class="comment cmt"><p>Set the last time modified of the file
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the new time</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#setLastModified(Long)
</p></span></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#moveDirectory" data-isabs="true">
      <a id="moveDirectory(Path,Boolean):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">moveDirectory</span>
        
        <span class="params">(<span name="target">target: <a name="scalax.file.Path" class="extype" href="">Path</a></span>, <span name="atomicMove">atomicMove: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Called to move the current directory to another location <strong>on the same filesystem</strong>
</p><div class="fullcomment"><div class="comment cmt"><p>Called to move the current directory to another location <strong>on the same filesystem</strong>
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected abstract </dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#moveFile" data-isabs="true">
      <a id="moveFile(Path,Boolean):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">moveFile</span>
        
        <span class="params">(<span name="target">target: <a name="scalax.file.Path" class="extype" href="">Path</a></span>, <span name="atomicMove">atomicMove: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Called to move the current file to another location <strong>on the same filesystem</strong>
</p><div class="fullcomment"><div class="comment cmt"><p>Called to move the current file to another location <strong>on the same filesystem</strong>
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected abstract </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#name" data-isabs="true">
      <a id="name:String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">name</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The name of the file.</p><div class="fullcomment"><div class="comment cmt"><p>The name of the file.  This includes the extension of the file</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the name of the file
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#open" data-isabs="true">
      <a id="open[R](Seq[OpenOption])((OpenSeekable) ⇒ R):R"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">open</span>
        <span class="tparams">[<span name="R">R</span>]</span>
        <span class="params">(<span name="openOptions">openOptions: Seq[<a name="scalax.io.OpenOption" class="extype" href="../io/OpenOption.html">OpenOption</a>] = <span class="symbol"><span class="name"><a href="../package.html">WriteTruncate</a></span></span></span>)</span><span class="params">(<span name="action">action: (OpenSeekable) ⇒ R</span>)</span><span class="result">: R</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Runs several operations as efficiently as possible.</p><div class="fullcomment"><div class="comment cmt"><p>Runs several operations as efficiently as possible. If the filesystem
permits random access then the same channel will be used to perform all operations.</p><p>Note: only the direct file operations (bytes,lines,write,patch etc...)
can be used and expected to use the same resource. The resource methods
all created new streams.</p><p>Note: not all file systems support this, if not then at worst the performance
is the same as if they where performed outside an open block</p></div><dl class="paramcmts block"><dt class="param">openOptions</dt><dd class="cmt"><p>
         The options that define how the file is opened for the duration of the
         operation
         Default is Write/Create/Truncate</p></dd><dt class="param">action</dt><dd class="cmt"><p>
         The function that will be executed within the block
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#outputStream" data-isabs="true">
      <a id="outputStream(OpenOption*):OutputStreamResource[OutputStream]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">outputStream</span>
        
        <span class="params">(<span name="openOptions">openOptions: <a name="scalax.io.OpenOption" class="extype" href="../io/OpenOption.html">OpenOption</a>*</span>)</span><span class="result">: <a name="scalax.io.OutputStreamResource" class="extype" href="../io/OutputStreamResource.html">OutputStreamResource</a>[<span name="java.io.OutputStream" class="extype">OutputStream</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtains an OutputStreamResource for writing to the file</p><div class="fullcomment"><div class="comment cmt"><p>Obtains an OutputStreamResource for writing to the file</p><p>All <code> OpenOption</code> can be used except Read which will be ignored if present
</p></div><dl class="paramcmts block"><dt class="param">openOptions</dt><dd class="cmt"><p>
          the options that define how the file is opened when using the stream
          The Write option is implicitly added to the set of options
          Default is write/create/truncate
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#parent" data-isabs="true">
      <a id="parent:Option[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">parent</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[<a name="scalax.file.Path" class="extype" href="">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The parent path segment if it is possible (for example a root will not have a parent)</p><div class="fullcomment"><div class="comment cmt"><p>The parent path segment if it is possible (for example a root will not have a parent)</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the parent path segment if it possible</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>parents
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#path" data-isabs="true">
      <a id="path:String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">path</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The path of the file.</p><div class="fullcomment"><div class="comment cmt"><p>The path of the file.  It may or may not be relative
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the path of the file
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#size" data-isabs="true">
      <a id="size:Option[Long]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">size</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[<span name="scala.Long" class="extype">Long</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The size of the file/directory in bytes
</p><div class="fullcomment"><div class="comment cmt"><p>The size of the file/directory in bytes
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The size of the file/directory in bytes</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#length()
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#toAbsolute" data-isabs="true">
      <a id="toAbsolute:Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toAbsolute</span>
        
        <span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Modifies the Path so that it is absolute from a root of the file system.</p><div class="fullcomment"><div class="comment cmt"><p>Modifies the Path so that it is absolute from a root of the file system.
However it is not necessarily canonical.  For example /home/user/../another
is a valid absolute path.
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>normalize
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#toURI" data-isabs="true">
      <a id="toURI:URI"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toURI</span>
        
        <span class="result">: <span name="java.net.URI" class="extype">URI</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a URI from the path.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a URI from the path.</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>See also</dt><dd><span class="cmt"><p>java.file.File#toURI
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#withLock" data-isabs="true">
      <a id="withLock[R](Long,Long,Boolean)((Seekable) ⇒ R):Option[R]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">withLock</span>
        <span class="tparams">[<span name="R">R</span>]</span>
        <span class="params">(<span name="start">start: <span name="scala.Long" class="extype">Long</span> = <span class="symbol">0</span></span>, <span name="size">size: <span name="scala.Long" class="extype">Long</span> = <span class="symbol">1</span></span>, <span name="shared">shared: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="params">(<span name="block">block: (<a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a>) ⇒ R</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[R]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs an operation on the file with a FileLock</p><div class="fullcomment"><div class="comment cmt"><p>Performs an operation on the file with a FileLock</p><p>Not all filesystems support locking.  If not then None will be returned by the method</p><p>The defaults will lock the entire file with an exclusive lock.  It is possible to modify the lock so that
it only locks part of the file and may be a shared lock.  Not all filesystems support shared locks but if that is
the case the lock will automatically be upgraded to a exclusiveLock</p><p>The sematics of this locking behavious are very similar to those in the <code> java.nio.channels.FileLock</code>
It is recommended that those javadocs are read and the warnings present in those docs are followed.
</p></div><dl class="paramcmts block"><dt class="param">start</dt><dd class="cmt"><p>
         the start position of the lock.  Must be a non-negative Long</p></dd><dt class="param">size</dt><dd class="cmt"><p>
         the length in bits the lock.  If -1 then the entire file from start to the end will be locked</p></dd><dt class="param">shared</dt><dd class="cmt"><p>
         If true then a shared lock will be obtained if possible.  If shared locks are not supported
         then an exclusive lock will be obtained
</p></dd><dt>returns</dt><dd class="cmt"><p>the result
         the result from the block or None if the filesystem does not support locking
</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>abstract </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a></dd></dl></div>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Concrete Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">##</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#*" data-isabs="false">
      <a id="*[U&gt;:Path, F](F)(PathMatcherFactory[F]):PathSet[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">*</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>, <span name="F">F</span>]</span>
        <span class="params">(<span name="filter">filter: F</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="factory">factory: <a name="scalax.file.PathMatcherFactory" class="extype" href="PathMatcherFactory.html">PathMatcherFactory</a>[F]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="PathSet.html">PathSet</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Constructs a new finder that selects all paths with a name that matches <code>filter</code> and are
immediate children of paths selected by this finder.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a new finder that selects all paths with a name that matches <code>filter</code> and are
immediate children of paths selected by this finder.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#**" data-isabs="false">
      <a id="**[U&gt;:Path, F](F)(PathMatcherFactory[F]):PathSet[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">**</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>, <span name="F">F</span>]</span>
        <span class="params">(<span name="filter">filter: F</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="factory">factory: <a name="scalax.file.PathMatcherFactory" class="extype" href="PathMatcherFactory.html">PathMatcherFactory</a>[F]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="PathSet.html">PathSet</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Constructs a new finder that selects all paths with a name that matches <code>filter</code> and are
descendants of paths selected by this finder.</p><div class="fullcomment"><div class="comment cmt"><p>Constructs a new finder that selects all paths with a name that matches <code>filter</code> and are
descendants of paths selected by this finder.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#***" data-isabs="false">
      <a id="***[U&gt;:Path]:PathSet[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">***</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>]</span>
        <span class="result">: <a name="scalax.file.PathSet" class="extype" href="PathSet.html">PathSet</a>[U]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#+++" data-isabs="false">
      <a id="+++[U&gt;:Path](PathFinder[U]):PathSet[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">+++</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>]</span>
        <span class="params">(<span name="includes">includes: <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a>[U]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="PathSet.html">PathSet</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The union of the paths found by this <code>PathSet</code> with the paths found by 'paths'.</p><div class="fullcomment"><div class="comment cmt"><p>The union of the paths found by this <code>PathSet</code> with the paths found by 'paths'.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#---" data-isabs="false">
      <a id="---[U&gt;:Path](PathFinder[U]):PathSet[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">---</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>]</span>
        <span class="params">(<span name="excludes">excludes: <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a>[U]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="PathSet.html">PathSet</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Excludes all paths from <code>excludes</code> from the paths selected by this <code>PathSet</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Excludes all paths from <code>excludes</code> from the paths selected by this <code>PathSet</code>.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#/" data-isabs="false">
      <a id="/(Path):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">/</span>
        
        <span class="params">(<span name="child">child: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Alias for /(child.</p><div class="fullcomment"><div class="comment cmt"><p>Alias for /(child.name)
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A new path with the specified path appended</p></dd></dl><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>See also</dt><dd><span class="cmt"><p>#/(String)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#&lt;" data-isabs="false">
      <a id="&lt;(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">&lt;</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered</dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#&lt;=" data-isabs="false">
      <a id="&lt;=(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">&lt;=</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#&gt;" data-isabs="false">
      <a id="&gt;(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">&gt;</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered</dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#&gt;=" data-isabs="false">
      <a id="&gt;=(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">&gt;=</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#\" data-isabs="false">
      <a id="\(Path):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">\</span>
        
        <span class="params">(<span name="child">child: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Alias for /(Path)</p><div class="fullcomment"><div class="comment cmt"><p>Alias for /(Path)</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>See also</dt><dd><span class="cmt"><p>#/(Path)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#\" data-isabs="false">
      <a id="\(String):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">\</span>
        
        <span class="params">(<span name="child">child: String</span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Alias for #/(String)
</p><div class="fullcomment"><div class="comment cmt"><p>Alias for #/(String)
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a></dd><dt>See also</dt><dd><span class="cmt"><p>#/(String)
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#access" data-isabs="false">
      <a id="access:AccessSet"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">access</span>
        
        <span class="result">: <a name="scalax.file.AccessSet" class="extype" href="AccessSet.html">AccessSet</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Reads the access modes from the file and returns the Set
This does not lock the file so the modes could be out of date
even by the time the method returns if used in a heavily
parallel environment
</p><div class="fullcomment"><div class="comment cmt"><p>Reads the access modes from the file and returns the Set
This does not lock the file so the modes could be out of date
even by the time the method returns if used in a heavily
parallel environment
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the access modes set on the file
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#access_=" data-isabs="false">
      <a id="access_=(String):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">access_=</span>
        
        <span class="params">(<span name="accessModes">accessModes: String</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Short cut for setting the standard access modes on the underlying path.</p><div class="fullcomment"><div class="comment cmt"><p>Short cut for setting the standard access modes on the underlying path.  If the
underlying object does not exist it will throw an exception.
If the underlying system does not support support the mode the mode
will be ignored
</p></div><dl class="paramcmts block"><dt class="param">accessModes</dt><dd class="cmt"><p>
         string representation of the modes. The standard options
         include r - read, w - write, e - execute.  The options are
         filesystem dependent
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#append" data-isabs="false">
      <a id="append(String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">append</span>
        
        <span class="params">(<span name="string">string: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Append a string to the end of the Seekable object.</p><div class="fullcomment"><div class="comment cmt"><p>Append a string to the end of the Seekable object.
</p></div><dl class="paramcmts block"><dt class="param">string</dt><dd class="cmt"><p>
         the data to write</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         the codec of the string to be written. The string will
         be converted to the encoding of <code> codec</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#append" data-isabs="false">
      <a id="append[T](T)(OutputConverter[T]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">append</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="data">data: T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="converter">converter: <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a>[T]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Append bytes to the end of a file</p><div class="fullcomment"><div class="comment cmt"><p>Append bytes to the end of a file</p><p><b>Important:</b> The use of an Array is highly recommended
 because normally arrays can be more efficiently written using
 the underlying APIs
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>
         The data to write.  This can be any type that has a <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> associated
         with it.  There are predefined $outputConverters for several types.  See the
         <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object for the predefined types and for objects to simplify implementing
         custom <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a></p><p>$converterParam
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.io.Seekable#appendChannel" data-isabs="false">
      <a id="appendChannel[U]((SeekableByteChannel) ⇒ U):U"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">appendChannel</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (<a name="scalax.io.SeekableByteChannel" class="extype" href="../io/SeekableByteChannel.html">SeekableByteChannel</a>) ⇒ U</span>)</span><span class="result">: U</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#appendIntsAsBytes" data-isabs="false">
      <a id="appendIntsAsBytes(Int*):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">appendIntsAsBytes</span>
        
        <span class="params">(<span name="data">data: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Since the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Since the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.  In other words just taking the first
 byte.  This is pretty common in Java.io style IO.  IE</p><pre>
 outputStream.write(1) 
</pre><p> 1 is written as a single byte.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#appendStrings" data-isabs="false">
      <a id="appendStrings(Traversable[String],String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">appendStrings</span>
        
        <span class="params">(<span name="strings">strings: <span name="scala.collection.Traversable" class="extype">Traversable</span>[String]</span>, <span name="separator">separator: String = <span class="symbol">&quot;&quot;</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Append several strings to the end of the Seekable object.</p><div class="fullcomment"><div class="comment cmt"><p>Append several strings to the end of the Seekable object.
</p></div><dl class="paramcmts block"><dt class="param">strings</dt><dd class="cmt"><p>
         The strings to write</p></dd><dt class="param">separator</dt><dd class="cmt"><p>
         A string to add between each string.
         It is not added to the before the first string
         or after the last.</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         The codec of the strings to be written. The strings will
         be converted to the encoding of <code> codec</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">asInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#attributes" data-isabs="false">
      <a id="attributes:Iterable[scalax.file.attributes.FileAttribute[_]]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">attributes</span>
        
        <span class="result">: Iterable[scalax.file.attributes.FileAttribute[_]]</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scalax.file.Path#attributes_=" data-isabs="false">
      <a id="attributes_=(Iterable[scalax.file.attributes.FileAttribute[_]]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">attributes_=</span>
        
        <span class="params">(<span name="attrs">attrs: Iterable[scalax.file.attributes.FileAttribute[_]]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scalax.io.Input#byteArray" data-isabs="false">
      <a id="byteArray:Array[Byte]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">byteArray</span>
        
        <span class="result">: <span name="scala.Array" class="extype">Array</span>[<span name="scala.Byte" class="extype">Byte</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">This method aspires to be the fastest way to read
a stream of known length into memory.</p><div class="fullcomment"><div class="comment cmt"><p>This method aspires to be the fastest way to read
a stream of known length into memory.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Input#bytes" data-isabs="false">
      <a id="bytes:ResourceView[Byte]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">bytes</span>
        
        <span class="result">: ResourceView[<span name="scala.Byte" class="extype">Byte</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtains a Traversable for conveniently processing the resource as bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Obtains a Traversable for conveniently processing the resource as bytes.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an non-strict traversable over all the bytes
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.FileOps#bytesAsInts" data-isabs="false">
      <a id="bytesAsInts:ResourceView[Int]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">bytesAsInts</span>
        
        <span class="result">: ResourceView[<span name="scala.Int" class="extype">Int</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtains a Traversable for conveniently processing the file as Ints.</p><div class="fullcomment"><div class="comment cmt"><p>Obtains a Traversable for conveniently processing the file as Ints.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>an non-strict traversable over all the bytes with the bytes being represented as Ints
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a> → <a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a> → <a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#canExecute" data-isabs="false">
      <a id="canExecute:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">canExecute</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scalax.file.Path#canRead" data-isabs="false">
      <a id="canRead:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">canRead</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scalax.file.Path#canWrite" data-isabs="false">
      <a id="canWrite:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">canWrite</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scalax.file.FileOps#chars" data-isabs="false">
      <a id="chars(Codec):ResourceView[Char]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">chars</span>
        
        <span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a></span>)</span><span class="result">: ResourceView[<span name="scala.Char" class="extype">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The characters in the object.</p><div class="fullcomment"><div class="comment cmt"><p>The characters in the object.$</p><p>If the codec is not the same as the source codec (the codec of
the underlying data) then the characters will converted to the
desired codec.
</p></div><dl class="paramcmts block"><dt class="param">codec</dt><dd class="cmt"><p>
         The codec representing the desired encoding of the characters
@return
         an traversable of all the characters
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a> → <a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a> → <a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#checkAccess" data-isabs="false">
      <a id="checkAccess(String):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">checkAccess</span>
        
        <span class="params">(<span name="modes">modes: String</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Check modes using the rwx characters.</p><div class="fullcomment"><div class="comment cmt"><p>Check modes using the rwx characters.  The string can be from 1-3 characters long and can be r w x in any order.
Spaces are ignored
</p></div></div>
    </li><li visbl="pub" name="scalax.file.Path#children" data-isabs="false">
      <a id="children[U&gt;:Path, F](F,Traversable[LinkOption])(PathMatcherFactory[F]):PathSet[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">children</span>
        <span class="tparams">[<span name="U">U &gt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>, <span name="F">F</span>]</span>
        <span class="params">(<span name="filter">filter: F</span>, <span name="options">options: <span name="scala.collection.Traversable" class="extype">Traversable</span>[<a name="scalax.file.LinkOption" class="extype" href="LinkOption.html">LinkOption</a>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="factory">factory: <a name="scalax.file.PathMatcherFactory" class="extype" href="PathMatcherFactory.html">PathMatcherFactory</a>[F]</span>)</span><span class="result">: <a name="scalax.file.PathSet" class="extype" href="PathSet.html">PathSet</a>[<a name="scalax.file.Path" class="extype" href="">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">An iterable over the contents of the directory.</p><div class="fullcomment"><div class="comment cmt"><p>An iterable over the contents of the directory.  This is simply walkTree with depth=1.</p><p>The filter parameter restricts what paths are available through the PathSet.  This is
different from using the filter, filterFold or filterEach methods in PathSet because PathMatchers can be used by
the underlying filesystem natively and can potentially provide dramatically improved performance for
very large directories.</p></div><dl class="paramcmts block"><dt class="param">filter</dt><dd class="cmt"><p>
         A filter that restricts what paths are available in the PathSet
         If the filter is a PathMatcher and the underlying filesystem supports the PatchMatcher
         implementation then the maximum performance will be achieved.
         All Paths that are passed to matcher is relative to this Path
         Default is PathMatcher.All
@return
         A managed resource managing a PathSet.
</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>FileSystem#matcher(String,String)
</p></span>, <span class="cmt"><p>Path.Matching</p></span>, <span class="cmt"><p>Path#walkTree</p></span></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">clone</span>
        
        <span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#compare" data-isabs="false">
      <a id="compare(Path):Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">compare</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Compares this path to the other lexigraphically.</p><div class="fullcomment"><div class="comment cmt"><p>Compares this path to the other lexigraphically.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → Ordered</dd></dl></div>
    </li><li visbl="pub" name="scala.math.Ordered#compareTo" data-isabs="false">
      <a id="compareTo(Path):Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">compareTo</span>
        
        <span class="params">(<span name="that">that: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Ordered → Comparable</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Input#copyData" data-isabs="false">
      <a id="copyData(Output):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">copyData</span>
        
        <span class="params">(<span name="output">output: <a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Copy all data from this Input object to the Output object
as efficiently as possible.</p><div class="fullcomment"><div class="comment cmt"><p>Copy all data from this Input object to the Output object
as efficiently as possible.
</p></div><dl class="paramcmts block"><dt class="param">output</dt><dd class="cmt"><p>output sink to copy the data to
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#copyTo" data-isabs="false">
      <a id="copyTo[P&lt;:Path](P,Boolean,Boolean,Boolean):P"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">copyTo</span>
        <span class="tparams">[<span name="P">P &lt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>]</span>
        <span class="params">(<span name="target">target: P</span>, <span name="createParents">createParents: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="copyAttributes">copyAttributes: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="replaceExisting">replaceExisting: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: P</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Copy the underlying object if it exists to the target location.</p><div class="fullcomment"><div class="comment cmt"><p> Copy the underlying object if it exists to the target location.
 If the underlying object is a directory it is not copied recursively.
</p></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>
          the target path to copy the filesystem object to.</p></dd><dt class="param">copyAttributes</dt><dd class="cmt"><p>
          if true then copy the File attributes of the object
          as well as the data.  True by default</p></dd><dt class="param">replaceExisting</dt><dd class="cmt"><p>
          if true then replace any existing target object
          unless it is a non-empty directory in which case
          an IOException is thrown.
          False by default</p><p> @return
          the path to the new copy</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#createDirectory" data-isabs="false">
      <a id="createDirectory(Boolean,Boolean,Iterable[AccessMode],Iterable[scalax.file.attributes.FileAttribute[_]]):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">createDirectory</span>
        
        <span class="params">(<span name="createParents">createParents: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>, <span name="failIfExists">failIfExists: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>, <span name="accessModes">accessModes: Iterable[<a name="scalax.file.Path.AccessModes.AccessMode" class="extype" href="Path$$AccessModes$$AccessMode.html">AccessMode</a>] = <span class="symbol"><span class="name"><a href="Path$.html">List(Read,Write,Execute)</a></span></span></span>, <span name="attributes">attributes: Iterable[scalax.file.attributes.FileAttribute[_]] = <span class="symbol">Nil</span></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create the directory referenced by this path.</p><div class="fullcomment"><div class="comment cmt"><p>Create the directory referenced by this path.</p><p>If failIfExists then IOException is thrown if the file already exists.
In the next Java 7 only version it will throw FileAlreadyExistsException</p><p>An exception is always thrown if the file is a directory and that directory
contains children</p><p>An exception will also be thrown if the parent directory does not have write
permission
</p></div><dl class="paramcmts block"><dt class="param">createParents</dt><dd class="cmt"><p>
         If true then the containing directories will be created if they do not exist
         Default is true</p></dd><dt class="param">failIfExists</dt><dd class="cmt"><p>
         If true and an object exists then an exception will be thrown
         If false then the object will be deleted if possible
         If not possible to delete the object or it is a non-empty directory
           an exception will be thrown
         Default is true</p></dd><dt class="param">accessModes</dt><dd class="cmt"><p>
         The access modes that to set on the file
         Default is Read,Write</p></dd><dt class="param">attributes</dt><dd class="cmt"><p>
         Filesystem specific attributes to fromString to the file
         Ignored unless on Java 7+ JVM
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#createFile" data-isabs="false">
      <a id="createFile(Boolean,Boolean,Iterable[AccessMode],Iterable[scalax.file.attributes.FileAttribute[_]]):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">createFile</span>
        
        <span class="params">(<span name="createParents">createParents: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>, <span name="failIfExists">failIfExists: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">true</span></span>, <span name="accessModes">accessModes: Iterable[<a name="scalax.file.Path.AccessModes.AccessMode" class="extype" href="Path$$AccessModes$$AccessMode.html">AccessMode</a>] = <span class="symbol"><span class="name"><a href="Path$.html">List(Read,Write)</a></span></span></span>, <span name="attributes">attributes: Iterable[scalax.file.attributes.FileAttribute[_]] = <span class="symbol">Nil</span></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create the file referenced by this path.</p><div class="fullcomment"><div class="comment cmt"><p>Create the file referenced by this path.</p><p>If failIfExists then IOException is thrown if the file already exists.
In the next Java 7 only version it will throw FileAlreadyExistsException</p><p>An exception is always thrown if the file is a directory and that directory
contains children</p><p>An Exception will also be thrown if the parent directory does not have write
permission
</p></div><dl class="paramcmts block"><dt class="param">createParents</dt><dd class="cmt"><p>
         If true then the containing directories will be created if they do not exist
         Default is true</p></dd><dt class="param">failIfExists</dt><dd class="cmt"><p>
         If true and an object exists then an exception will be thrown
         If false then the object will be deleted if possible
         If not possible to delete the object or it is a non-empty directory
           an exception will be thrown
         Default is true</p></dd><dt class="param">accessModes</dt><dd class="cmt"><p>
         The access modes that to set on the file
         Default is Read,Write</p></dd><dt class="param">attributes</dt><dd class="cmt"><p>
         Filesystem specific attributes to fromString to the file
         Ignored unless on Java 7+ JVM</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#deleteIfExists" data-isabs="false">
      <a id="deleteIfExists(Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">deleteIfExists</span>
        
        <span class="params">(<span name="force">force: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Delete the filesystem object if the file exists.</p><div class="fullcomment"><div class="comment cmt"><p> Delete the filesystem object if the file exists.</p><p> If the file exists and is a non-empty Directory or
 there is some other reason the operation cannot be performed an
 IOException will be thrown.</p><p> If the file does not exist it will return false
</p></div><dl class="paramcmts block"><dt class="param">force</dt><dd class="cmt"><p>
         if the file is write protected force will override
         the write protection and delete the file.  If not
         force then an IOException will be thrown indicating
         failure of deletion.
         Default is false</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#deleteRecursively" data-isabs="false">
      <a id="deleteRecursively(Boolean,Boolean):(Int, Int)"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">deleteRecursively</span>
        
        <span class="params">(<span name="force">force: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>, <span name="continueOnFailure">continueOnFailure: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="result">: (<span name="scala.Int" class="extype">Int</span>, <span name="scala.Int" class="extype">Int</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Deletes the directory recursively.</p><div class="fullcomment"><div class="comment cmt"><p> Deletes the directory recursively.</p><p> This method does not detect circular directory graphs and
 does not promise to perform the delete in an atomic operation</p><p>Use with caution!</p></div><dl class="paramcmts block"><dt class="param">force</dt><dd class="cmt"><p>
         if the file is write protected force will override
         the write protection and delete the file.  If not
         force then an IOException will be thrown indicating
         failure of deletion.
         Default is false</p></dd><dt class="param">continueOnFailure</dt><dd class="cmt"><p>
          If false then method will throw an exception when encountering a
          file that cannot be deleted.  Otherwise it will continue
          to delete all the files that can be deleted.
          Note:  this method is not transactional, all files visited before
          failure are deleted.</p><p> @return
          Tuple with (The number of files deleted, The number of files remaining)</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#endsWith" data-isabs="false">
      <a id="endsWith(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">endsWith</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if this path ends with the other path</p><div class="fullcomment"><div class="comment cmt"><p>True if this path ends with the other path</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if this path ends with the other path
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">eq</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">equals</span>
        
        <span class="params">(<span name="other">other: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#extension" data-isabs="false">
      <a id="extension:Option[String]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">extension</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The extension of the name of the path, if it exists.</p><div class="fullcomment"><div class="comment cmt"><p>The extension of the name of the path, if it exists. if name ends with an
extension (e.g. &quot;foo.jpg&quot;) returns the extension (&quot;jpg&quot;)
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the extension of the path
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#fileSystem" data-isabs="false">
      <a id="fileSystem:FileSystem"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">fileSystem</span>
        
        <span class="result">: <a name="scalax.file.FileSystem" class="extype" href="FileSystem.html">FileSystem</a></span>
      </span>
      </h4>
      
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">finalize</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">getClass</span>
        
        <span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">hashCode</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#insert" data-isabs="false">
      <a id="insert[T](Long,T)(OutputConverter[T]):Any"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">insert</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="data">data: T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="converter">converter: <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a>[T]</span>)</span><span class="result">: <span name="scala.Any" class="extype">Any</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts data at a position in the Seekable.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts data at a position in the Seekable.  The actual position in the Seekable where the data is inserted depends on
the type of data being written.  For example if Longs are being written then position calculated as position * 8</p><p><b>Important:</b> The use of an Array is highly recommended
 because normally arrays can be more efficiently written using
 the underlying APIs
</p></div><dl class="paramcmts block"><dt class="param">position</dt><dd class="cmt"><p>The position where the data is inserted into the Seekable.  The actual position in the Seekable
where the data is inserted depends on the type of data being written.  For example if
Longs are being written then position calculated as position * 8
</p></dd><dt class="param">data</dt><dd class="cmt"><p>
         The data to write.  This can be any type that has a <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> associated
         with it.  There are predefined $outputConverters for several types.  See the
         <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object for the predefined types and for objects to simplify implementing
         custom <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a></p><p>$converterParam
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#insert" data-isabs="false">
      <a id="insert(Long,String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">insert</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="string">string: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Inserts a string at a position in the Seekable.</p><div class="fullcomment"><div class="comment cmt"><p>Inserts a string at a position in the Seekable. This is a potentially inefficient because of the need to
count characters.  If the codec is not a fixed sized codec (for example UTF8) each character must be
converted in the file up to the point of insertion.
</p></div><dl class="paramcmts block"><dt class="param">position</dt><dd class="cmt"><p>The position in the file to perform the insert.  A position of 2 will insert the character after
             the second character (not byte).</p></dd><dt class="param">string</dt><dd class="cmt"><p>The string that will be inserted into the Seekable</p></dd><dt class="param">codec</dt><dd class="cmt"><p>The codec to use for determining the location for inserting the string and for encoding the
             string as bytes
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#insertIntsAsBytes" data-isabs="false">
      <a id="insertIntsAsBytes(Long,Int*):Any"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">insertIntsAsBytes</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="data">data: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <span name="scala.Any" class="extype">Any</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Since the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Since the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.  In other words just taking the first
 byte.  This is pretty common in Java.io style IO.  IE</p><pre>
 outputStream.write(1) 
</pre><p> 1 is written as a single byte.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isFresher" data-isabs="false">
      <a id="isFresher(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isFresher</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if this path has been modified more recently than other.</p><div class="fullcomment"><div class="comment cmt"><p>True if this path has been modified more recently than other.
If this file does not exist it is not fresh than other
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if this path has been modified more recently than other.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isSame" data-isabs="false">
      <a id="isSame(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isSame</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if this path and the other path reference the same file.</p><div class="fullcomment"><div class="comment cmt"><p>True if this path and the other path reference the same file.</p><p>This means the two paths may have different segments and perhaps
even have symlinks in the path but if they reference the same file
then this will return true.  Use equals to test if the paths are the same</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if this path and the other path reference the same file.
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#isSymlink" data-isabs="false">
      <a id="isSymlink:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isSymlink</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if the file is a symlink.</p><div class="fullcomment"><div class="comment cmt"><p>True if the file is a symlink.</p><p>This method is generally correct but depending
the filesystem there is a possibility of getting the
the incorrect result since the canonical and absolute
paths are compared and no native code is used.  Future
versions will be guaranteed to work correctly but this version
cannot be because of limitations of the VM.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if the file is a symlink.
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#iterator" data-isabs="false">
      <a id="iterator:Iterator[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">iterator</span>
        
        <span class="result">: Iterator[<a name="scalax.file.Path" class="extype" href="">Path</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Input#lines" data-isabs="false">
      <a id="lines(Terminator,Boolean)(Codec):ResourceView[String]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">lines</span>
        
        <span class="params">(<span name="terminator">terminator: <a name="scalax.io.Line.Terminators.Terminator" class="extype" href="../io/Line$$Terminators$$Terminator.html">Terminator</a> = <span class="symbol"><span class="name"><a href="../io/Line$.html">new Terminators.Auto()</a></span></span></span>, <span name="includeTerminator">includeTerminator: <span name="scala.Boolean" class="extype">Boolean</span> = <span class="symbol">false</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: ResourceView[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Obtain an non-strict traversable for iterating through the lines in the object</p><div class="fullcomment"><div class="comment cmt"><p>Obtain an non-strict traversable for iterating through the lines in the object</p><p>If the codec is not the same as the source codec (the codec of
the underlying data) then the characters will converted to the
desired codec.
</p></div><dl class="paramcmts block"><dt class="param">terminator</dt><dd class="cmt"><p>
         The strategy for determining the end of line
         Default is to auto-detect the EOL</p></dd><dt class="param">includeTerminator</dt><dd class="cmt"><p>
         if true then the line will end with the line terminator
         Default is false</p><p>@return
         a non-strict traversable for iterating through all the lines
</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         The codec representing the desired encoding of the characters</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#matcher" data-isabs="false">
      <a id="matcher(String,String):PathMatcher"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">matcher</span>
        
        <span class="params">(<span name="pattern">pattern: String</span>, <span name="syntax">syntax: String = <span class="symbol"><span class="name"><a href="PathMatcher$.html">PathMatcher.StandardSyntax.GLOB</a></span></span></span>)</span><span class="result">: <a name="scalax.file.PathMatcher" class="extype" href="PathMatcher.html">PathMatcher</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a matcher from this path's filesystem</p><div class="fullcomment"><div class="comment cmt"><p>Create a matcher from this path's filesystem</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>FileSystem # matcher ( String, String )
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#moveTo" data-isabs="false">
      <a id="moveTo[P&lt;:Path](P,Boolean,Boolean):P"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">moveTo</span>
        <span class="tparams">[<span name="P">P &lt;: <a name="scalax.file.Path" class="extype" href="">Path</a></span>]</span>
        <span class="params">(<span name="target">target: P</span>, <span name="replace">replace: <span name="scala.Boolean" class="extype">Boolean</span></span>, <span name="atomicMove">atomicMove: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: P</span>
      </span>
      </h4>
      <p class="shortcomment cmt"> Move the underlying object if it exists to the target location.</p><div class="fullcomment"><div class="comment cmt"><p> Move the underlying object if it exists to the target location.</p><p> If copying of the file is required this will happen, as long as
 atomicMove = false.  If atomicMove = true and the move requires copy then
 deletion an exception will be thrown.  This is filesystem dependent</p></div><dl class="paramcmts block"><dt class="param">target</dt><dd class="cmt"><p>
          the target path to move the filesystem object to.</p></dd><dt class="param">atomicMove</dt><dd class="cmt"><p>
          it will guarantee atomicity of the move
          False by default
</p></dd><dt>returns</dt><dd class="cmt"><p>true
          the path to the moved object</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">ne</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#nonExistent" data-isabs="false">
      <a id="nonExistent:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">nonExistent</span>
        
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt"> False if the path does not exist in the file system
</p><div class="fullcomment"><div class="comment cmt"><p> False if the path does not exist in the file system
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>false if the path does not exist in the file system
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#normalize" data-isabs="false">
      <a id="normalize:Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">normalize</span>
        
        <span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the related Path that starts at a root of the file system and is the direct
path with all relative segments are resolved.</p><div class="fullcomment"><div class="comment cmt"><p>Returns the related Path that starts at a root of the file system and is the direct
path with all relative segments are resolved.</p><p>For example /home/user/../another is <em>not</em> a valid canonical path.</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>java.file.File#toCanonical
</p></span>, <span class="cmt"><p>#toAbsolute</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notify</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notifyAll</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#open" data-isabs="false">
      <a id="open[U]((OpenSeekable) ⇒ U):U"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">open</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (OpenSeekable) ⇒ U</span>)</span><span class="result">: U</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the function 'f' passing an Seekable instance that performs all operations
on a single opened connection to the underlying resource.</p><div class="fullcomment"><div class="comment cmt"><p>Execute the function 'f' passing an Seekable instance that performs all operations
on a single opened connection to the underlying resource. Typically each call to
one of the Seekable's methods results in a new connection.  For example if write it called
typically it will write to the start of the seekable but in open it will write to the
current position.</p><p>Even if the underlying resource is an appending, using open will be more efficient since
the connection only needs to be made a single time.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to execute on the new Output instance (which uses a single connection)</p></dd><dt>returns</dt><dd class="cmt"><p>the result of the function
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#openOutput" data-isabs="false">
      <a id="openOutput[U]((Output) ⇒ U):U"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">openOutput</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (<a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a>) ⇒ U</span>)</span><span class="result">: U</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the function 'f' passing an Output instance that performs all operations
on a single opened connection to the underlying resource.</p><div class="fullcomment"><div class="comment cmt"><p>Execute the function 'f' passing an Output instance that performs all operations
on a single opened connection to the underlying resource. Typically each call to
one of the Output's methods results in a new connection.  For example if the underlying
OutputStream truncates the file each time the connection is made then calling write
two times will result in the contents of the second write overwriting the second write.</p><p>Even if the underlying resource is an appending, using open will be more efficient since
the connection only needs to be made a single time.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the function to execute on the new Output instance (which uses a single connection)</p></dd><dt>returns</dt><dd class="cmt"><p>the result of the function
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#parents" data-isabs="false">
      <a id="parents:List[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">parents</span>
        
        <span class="result">: List[<a name="scalax.file.Path" class="extype" href="">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The path segments of the path excluding the current path segment.</p><div class="fullcomment"><div class="comment cmt"><p>The path segments of the path excluding the current path segment.  The first
segment is the first segment in the path.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>The path segments of the path excluding the current path segment</p></dd></dl><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>segments
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#patch" data-isabs="false">
      <a id="patch[T](Long,T,Overwrite)(OutputConverter[T]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">patch</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="data">data: T</span>, <span name="overwrite">overwrite: <a name="scalax.io.Overwrite" class="extype" href="../io/Overwrite.html">Overwrite</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="converter">converter: <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a>[T]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Update a portion of the file content at
 the declared location.</p><div class="fullcomment"><div class="comment cmt"><p>Update a portion of the file content at
 the declared location. This is the most flexible of the
 random access methods but is also (probably) the trickiest
 to fully understand.  That said it behaves (almost) identical
 to a scala.collection.Seq.patch method, so if you understand that
 you should not have difficulty understanding this method.</p><p><b>Important:</b> The use of an Array is highly recommended
 because normally arrays can be more efficiently written using
 the underlying APIs</p><p>To append data the <code>position must &gt;= size</code></p><p>If the position is within the file but the
<code>position + bytes.length</code>
is beyond the end of the file the file will be enlarged so
that the entire string can fit in the file</p><p>The write begins at the position indicated.  So if position = 0
then the write will begin at the first byte of the file.
</p></div><dl class="paramcmts block"><dt class="param">position</dt><dd class="cmt"><p>
         The start position of the update starting at 0.
         The position must be within the file or == size (for appending)</p></dd><dt class="param">data</dt><dd class="cmt"><p>
         The data to write.  This can be any type that has a <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> associated
         with it.  There are predefined $outputConverters for several types.  See the
         <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object for the predefined types and for objects to simplify implementing
         custom <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a></p></dd><dt class="param">overwrite</dt><dd class="cmt"><p>The strategy that dictates how many characters/bytes/units are overwritten
$converterParam
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#patch" data-isabs="false">
      <a id="patch(Long,String,Overwrite)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">patch</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="string">string: String</span>, <span name="overwrite">overwrite: <a name="scalax.io.Overwrite" class="extype" href="../io/Overwrite.html">Overwrite</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Update a portion of the file content at
 the declared location.</p><div class="fullcomment"><div class="comment cmt"><p>Update a portion of the file content at
 the declared location. This is the most flexible of the
 random access methods but is also (probably) the trickiest
 to fully understand.  That said it behaves (almost) identical
 to a scala.collection.Seq.patch method, so if you understand that
 you should not have difficulty understanding this method.</p><p>If the position is beyond the end of the file a BufferUnderflow
Exception will be thrown</p><p>If the position is within the file but the
<code>position + string.getBytes(codec).length</code>
is beyond the end of the file the file will be enlarged so
that the entire string can fit in the file</p><p>The write begins at the position indicated.  So if position = 0
then the write will begin at the first byte of the file.
</p></div><dl class="paramcmts block"><dt class="param">position</dt><dd class="cmt"><p>
         The start position of the update starting at 0.
         The position is the position'th character in the file using
         the codec for decoding the file
         The position must be within the file.</p></dd><dt class="param">string</dt><dd class="cmt"><p>
         The string to write to the file starting at
         position.</p></dd><dt class="param">overwrite</dt><dd class="cmt"><p>The strategy that dictates how many characters/bytes/units are overwritten</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         The codec to use for decoding the underlying data into characters
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#patchIntsAsBytes" data-isabs="false">
      <a id="patchIntsAsBytes(Long,Overwrite,Int*):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">patchIntsAsBytes</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>, <span name="overwrite">overwrite: <a name="scalax.io.Overwrite" class="extype" href="../io/Overwrite.html">Overwrite</a></span>, <span name="data">data: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Since the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Since the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
 is provided to simply write an array of Ints as if they are Bytes.  In other words just taking the first
 byte.  This is pretty common in Java.io style IO.  IE</p><pre>
 outputStream.write(1) 
</pre><p> 1 is written as a single byte.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.io.Seekable#readWriteChannel" data-isabs="false">
      <a id="readWriteChannel[U]((SeekableByteChannel) ⇒ U):U"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">readWriteChannel</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (<a name="scalax.io.SeekableByteChannel" class="extype" href="../io/SeekableByteChannel.html">SeekableByteChannel</a>) ⇒ U</span>)</span><span class="result">: U</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#relativize" data-isabs="false">
      <a id="relativize(Path):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">relativize</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Make the current path relative to the other path.</p><div class="fullcomment"><div class="comment cmt"><p>Make the current path relative to the other path.  If the two paths
are on different drives then the other path is returned. If the two
paths have different roots the other path is returned.  If the two paths
reference the same path then the other path is returned</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>relative path from the current path to the other path
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#resolve" data-isabs="false">
      <a id="resolve(String):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">resolve</span>
        
        <span class="params">(<span name="other">other: String</span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Constructs a path from other using the same file system as this
path and resolves the this and other in the same manner as
<code> Path#resolve(Path)</code></p>
    </li><li visbl="pub" name="scalax.file.Path#resolve" data-isabs="false">
      <a id="resolve(Path):Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">resolve</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Resolve this path with other.</p><div class="fullcomment"><div class="comment cmt"><p>Resolve this path with other.  In the simplest case
that means appending other to this.</p><p> Does the same thing as the / method
</p></div><dl class="paramcmts block"><dt class="param">other</dt><dd class="cmt"><p>
         another path to append to this path
@return
         the constructed/resolved path</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#root" data-isabs="false">
      <a id="root:Option[Path]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">root</span>
        
        <span class="result">: <span name="scala.Option" class="extype">Option</span>[<a name="scalax.file.Path" class="extype" href="">Path</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The root of the file system of the path if it can be determined.</p><div class="fullcomment"><div class="comment cmt"><p>The root of the file system of the path if it can be determined.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the root of the file system
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#segments" data-isabs="false">
      <a id="segments:List[String]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">segments</span>
        
        <span class="result">: List[String]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The segments in the path including the current element of the path.</p><div class="fullcomment"><div class="comment cmt"><p>The segments in the path including the current element of the path.  If the
the path is relative only the segments defined are returned... NOT the absolute
path</p><p>Note segments.last should == name
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the segments in the path
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#separator" data-isabs="false">
      <a id="separator:String"></a>
      <h4 class="signature">
      <span class="kind">val</span>
      <span class="symbol"> 
        <span class="name">separator</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The path segment separator string for
the filesystem
</p><div class="fullcomment"><div class="comment cmt"><p>The path segment separator string for
the filesystem
</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>FileSystem#separator
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#simpleName" data-isabs="false">
      <a id="simpleName:String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">simpleName</span>
        
        <span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">The name of the file excluding of the file</p><div class="fullcomment"><div class="comment cmt"><p>The name of the file excluding of the file</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>name of the file excluding of the file
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Input#slurpString" data-isabs="false">
      <a id="slurpString(Codec):String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">slurpString</span>
        
        <span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: String</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loads all the characters into memory.</p><div class="fullcomment"><div class="comment cmt"><p>Loads all the characters into memory. There is no protection against
loading very large files/amounts of data.</p><p>If the codec is not the same as the source codec (the codec of
the underlying data) then the characters will converted to the
desired codec.
</p></div><dl class="paramcmts block"><dt class="param">codec</dt><dd class="cmt"><p>
         The codec representing the desired encoding of the characters
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#startsWith" data-isabs="false">
      <a id="startsWith(Path):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">startsWith</span>
        
        <span class="params">(<span name="other">other: <a name="scalax.file.Path" class="extype" href="">Path</a></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">True if this path starts with the other path</p><div class="fullcomment"><div class="comment cmt"><p>True if this path starts with the other path</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>True if this path starts with the other path
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">synchronized</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="prt" name="scalax.file.Path#tempFile" data-isabs="false">
      <a id="tempFile():Path"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">tempFile</span>
        
        <span class="params">()</span><span class="result">: <a name="scalax.file.Path" class="extype" href="">Path</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a temporary file to use for performing certain operations.</p><div class="fullcomment"><div class="comment cmt"><p>Create a temporary file to use for performing certain operations.  It should
be as efficient as possible to copy from the temporary file to this Seekable and
vice-versa.  Can be overridden for performance
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → <a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toString</span>
        
        <span class="params">()</span><span class="result">: String</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.file.Path" class="extype" href="">Path</a> → AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.file.Path#toURL" data-isabs="false">
      <a id="toURL:URL"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toURL</span>
        
        <span class="result">: <span name="java.net.URL" class="extype">URL</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Creates a URL from the path.</p><div class="fullcomment"><div class="comment cmt"><p>Creates a URL from the path.  This does have the bug present in <code> java.file.File#toURL</code>
and can be used directly.</p></div><dl class="attributes block"> <dt>See also</dt><dd><span class="cmt"><p>java.file.File#toURI
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#truncate" data-isabs="false">
      <a id="truncate(Long):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">truncate</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Truncate/Chop the Seekable to the number of bytes declared by the position param
</p><div class="fullcomment"><div class="comment cmt"><p>Truncate/Chop the Seekable to the number of bytes declared by the position param
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Seekable#truncateString" data-isabs="false">
      <a id="truncateString(Long)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">truncateString</span>
        
        <span class="params">(<span name="position">position: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.FileOps#underlyingChannel" data-isabs="false">
      <a id="underlyingChannel(Boolean):OpenedResource[SeekableByteChannel]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">underlyingChannel</span>
        
        <span class="params">(<span name="append">append: <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="scalax.io.OpenedResource" class="extype" href="../io/OpenedResource.html">OpenedResource</a>[<a name="scalax.io.SeekableByteChannel" class="extype" href="../io/SeekableByteChannel.html">SeekableByteChannel</a>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a> → <a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></dd></dl></div>
    </li><li visbl="prt" name="scalax.file.FileOps#underlyingOutput" data-isabs="false">
      <a id="underlyingOutput:OutputStreamResource[OutputStream]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">underlyingOutput</span>
        
        <span class="result">: <a name="scalax.io.OutputStreamResource" class="extype" href="../io/OutputStreamResource.html">OutputStreamResource</a>[<span name="java.io.OutputStream" class="extype">OutputStream</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a> → <a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a> → <a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#write" data-isabs="false">
      <a id="write(String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">write</span>
        
        <span class="params">(<span name="string">string: String</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Writes a string.</p><div class="fullcomment"><div class="comment cmt"><p>Writes a string.
</p></div><dl class="paramcmts block"><dt class="param">string</dt><dd class="cmt"><p>
         the data to write</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         the codec of the string to be written. The string will
         be converted to the encoding of <code> sourceCodec</code>
         Default is sourceCodec
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#write" data-isabs="false">
      <a id="write[T](T)(OutputConverter[T]):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">write</span>
        <span class="tparams">[<span name="T">T</span>]</span>
        <span class="params">(<span name="data">data: T</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="writer">writer: <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a>[T]</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Write data to the underlying object.</p><div class="fullcomment"><div class="comment cmt"><p>Write data to the underlying object.  Each time write is called the resource is reopened, in the case of a
file this means that the file will be opened and truncated.  The</p><p>In the case of writing ints and bytes it is often
recommended to write arrays of data since normally the underlying object can write arrays
of bytes or integers most efficiently.</p><p>Since Characters require a codec to write to an OutputStream characters cannot be written with this method
unless a OutputWriterFunction.CharFunction object is provided as the writer.
</p></div><dl class="paramcmts block"><dt class="param">data</dt><dd class="cmt"><p>
         The data to write to underlying object.  Any data that has a resolvable <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> can
         be written.  See the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object for the defined <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a>
         implementations and classes to assist implementing more.</p></dd><dt class="param">writer</dt><dd class="cmt"><p>
         The strategy used to write the data to the underlying object.  Many standard data-types are implicitly
         resolved and do not need to be supplied
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></dd><dt>See also</dt><dd><span class="cmt"><p>#writeChars for more on writing characters
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#writeChars" data-isabs="false">
      <a id="writeChars(TraversableOnce[Char])(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">writeChars</span>
        
        <span class="params">(<span name="characters">characters: TraversableOnce[<span name="scala.Char" class="extype">Char</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#writeIntsAsBytes" data-isabs="false">
      <a id="writeIntsAsBytes(Int*):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">writeIntsAsBytes</span>
        
        <span class="params">(<span name="data">data: <span name="scala.Int" class="extype">Int</span>*</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Since the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
is provided to simply write an array of Ints as if they are Bytes.</p><div class="fullcomment"><div class="comment cmt"><p>Since the <a name="scalax.io.OutputConverter" class="extype" href="../io/OutputConverter.html">OutputConverter</a> object defined for writing Ints encodes Ints using 4 bytes this method
is provided to simply write an array of Ints as if they are Bytes.  In other words just taking the first
byte.  This is pretty common in Java.io style IO.  IE</p><pre>
 outputStream.write(1) 
</pre><p>1 is written as a single byte.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.Output#writeStrings" data-isabs="false">
      <a id="writeStrings(Traversable[String],String)(Codec):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">writeStrings</span>
        
        <span class="params">(<span name="strings">strings: <span name="scala.collection.Traversable" class="extype">Traversable</span>[String]</span>, <span name="separator">separator: String = <span class="symbol">&quot;&quot;</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="codec">codec: <a name="scalax.io.Codec" class="extype" href="../io/Codec.html">Codec</a> = <span class="symbol"><span class="name"><a href="../io/Codec$.html">Codec.default</a></span></span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Write several strings.</p><div class="fullcomment"><div class="comment cmt"><p>Write several strings.
</p></div><dl class="paramcmts block"><dt class="param">strings</dt><dd class="cmt"><p>
         The data to write</p></dd><dt class="param">separator</dt><dd class="cmt"><p>
         A string to add between each string.
         It is not added to the before the first string
         or after the last.</p></dd><dt class="param">codec</dt><dd class="cmt"><p>
         The codec of the strings to be written. The strings will
         be converted to the encoding of <code> sourceCodec</code>
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></dd></dl></div>
    </li></ol>
            </div>

        

        <div name="scala.math.Ordered" class="parent">
              <h3>Inherited from <span name="scala.math.Ordered" class="extype">Ordered</span>[<a name="scalax.file.Path" class="extype" href="">Path</a>]</h3>
            </div><div name="java.lang.Comparable" class="parent">
              <h3>Inherited from <span name="java.lang.Comparable" class="extype">Comparable</span>[<a name="scalax.file.Path" class="extype" href="">Path</a>]</h3>
            </div><div name="scalax.file.PathFinder" class="parent">
              <h3>Inherited from <a name="scalax.file.PathFinder" class="extype" href="PathFinder.html">PathFinder</a>[<a name="scalax.file.Path" class="extype" href="">Path</a>]</h3>
            </div><div name="scalax.file.FileOps" class="parent">
              <h3>Inherited from <a name="scalax.file.FileOps" class="extype" href="FileOps.html">FileOps</a></h3>
            </div><div name="scalax.io.Seekable" class="parent">
              <h3>Inherited from <a name="scalax.io.Seekable" class="extype" href="../io/Seekable.html">Seekable</a></h3>
            </div><div name="scalax.io.Output" class="parent">
              <h3>Inherited from <a name="scalax.io.Output" class="extype" href="../io/Output.html">Output</a></h3>
            </div><div name="scalax.io.Input" class="parent">
              <h3>Inherited from <a name="scalax.io.Input" class="extype" href="../io/Input.html">Input</a></h3>
            </div><div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>

      </div>
      
      <div id="tooltip"></div>
      
    </body>
      </html>