<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>CharProcessorAPI - Scala IO - scalax.io.processing.CharProcessorAPI</title>
          <meta name="description" content="CharProcessorAPI - Scala IO - scalax.io.processing.CharProcessorAPI" />
          <meta name="keywords" content="CharProcessorAPI Scala IO scalax.io.processing.CharProcessorAPI" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'scalax.io.processing.CharProcessorAPI';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/class_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="scalax">scalax</a>.<a href="../package.html" class="extype" name="scalax.io">io</a>.<a href="package.html" class="extype" name="scalax.io.processing">processing</a></p>
        <h1>CharProcessorAPI</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">CharProcessorAPI</span><span class="result"> extends <a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a>[<span class="extype" name="scala.Char">Char</span>], <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="scalax.io.processing.CharProcessorAPI"><span>CharProcessorAPI</span></li><li class="in" name="scalax.io.processing.ProcessorAPI"><span>ProcessorAPI</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">java.lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#drop" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="drop(i:Int):scalax.io.processing.Processor[Unit]"></a>
      <a id="drop(Int):Processor[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">drop</span><span class="params">(<span name="i">i: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Drop/skip the next i elements in the input source if possible.</p><div class="fullcomment"><div class="comment cmt"><p>Drop/skip the next i elements in the input source if possible.</p><p>Since dropping results in nothing the result can be ignored.</p><pre><span class="cmt">// results in a Processor[Seq[<type of processor>]]</span>
<span class="kw">for</span> {
  api <span class="kw">&lt;-</span> input.processor
  _ <span class="kw">&lt;-</span> api.drop(<span class="num">10</span>)
  seq <span class="kw">&lt;-</span> api.take(<span class="num">5</span>)
} <span class="kw">yield</span> seq</pre></div><dl class="paramcmts block"><dt class="param">i</dt><dd class="cmt"><p>the number of elements to skip</p></dd><dt>returns</dt><dd class="cmt"><p>the returned Processor can typically be ignored since it is a unit processor.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#end" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="end():scalax.io.processing.Processor[Unit]"></a>
      <a id="end():Processor[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">end</span><span class="params">()</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Ends the ProcessAPI.</p><div class="fullcomment"><div class="comment cmt"><p>Ends the ProcessAPI.  Any attempts to take or drop will have no effect after the process is ended.</p><pre><span class="kw">for</span> {
  api <span class="kw">&lt;-</span> input.processor
  _ <span class="kw">&lt;-</span> repeatUntilEmpty
  seq <span class="kw">&lt;-</span> api.take(<span class="num">5</span>)
  <span class="kw">if</span>(seq contains <span class="num">1</span>)
  _ <span class="kw">&lt;-</span> api.end
} <span class="kw">yield</span> seq</pre><p>Example takes 5 elements from the input source until it contains the value 1 then it ends the repeating and returns
the seq.</p><p>The resulting Processor will be of type Processor[Iterator[Seq[A] ] ], even though there can only be one element, thus
calling: result.traversable.headOption is likely the easiest method of obtaining the value from the Processor</p><p>Just a side note:
  This could be done with a LongTraversable with:  traversable.sliding(5,5).filter(_ contains 1).headOption
  Note that you need to use headOption because you don't know if there are any elements in the resulting traversable,
  however the LongTraversable API would be difficult to use if you want to processes multiple input objects together
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a Processor[Unit] and therefore the result can normally be ignored
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#endIf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="endIf(f:=&gt;Boolean):scalax.io.processing.Processor[Unit]"></a>
      <a id="endIf(⇒Boolean):Processor[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">endIf</span><span class="params">(<span name="f">f: ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">End the processes if the predicate return true.</p><div class="fullcomment"><div class="comment cmt"><p>End the processes if the predicate return true.  Any attempts to take or drop will have no effect after the process is ended.</p><pre><span class="kw">for</span> {
  api <span class="kw">&lt;-</span> input.processor
  _ <span class="kw">&lt;-</span> repeatUntilEmpty()
  seq <span class="kw">&lt;-</span> input.take(<span class="num">5</span>)
  _ <span class="kw">&lt;-</span> input.endIf(_ contains <span class="num">25</span>)
} <span class="kw">yield</span> seq</pre><p>The Example takes 5 elements of the input until one of the sequences contains the number 25.</p><p>As a side note:
  This could be done using the LongTraversable API: traversable.sliding(5,5).takeWhile(i =&gt; !(i contains 25))
  While this example can be done with the normal traversable API, this API is typically preferred when
  reading data from multiple interdependent sources.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the predi</p></dd><dt>returns</dt><dd class="cmt"><p>a Processor[Unit] and therefore the result can normally be ignored
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">java.lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scalax.io.processing.CharProcessorAPI#line" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="line(includeTerminator:Boolean,lineTerminator:scalax.io.Line.Terminators.Terminator):scalax.io.processing.Processor[Seq[Char]]"></a>
      <a id="line(Boolean,Terminator):Processor[Seq[Char]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">line</span><span class="params">(<span name="includeTerminator">includeTerminator: <span class="extype" name="scala.Boolean">Boolean</span> = <span class="symbol">false</span></span>, <span name="lineTerminator">lineTerminator: <a href="../Line$$Terminators$$Terminator.html" class="extype" name="scalax.io.Line.Terminators.Terminator">Terminator</a> = <span class="symbol"><span class="name"><a href="../Line$.html">Line.Terminators.Auto</a></span></span></span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scala.collection.Seq">Seq</span>[<span class="extype" name="scala.Char">Char</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Read the sequence of characters from the current element in the input source if A are Char.</p><div class="fullcomment"><div class="comment cmt"><p>Read the sequence of characters from the current element in the input source if A are Char.</p><p>In practical terms the implicit portion of the method signature can be ignored.  It is required to make the method
type safe so that a method call to the method will only compile when the type of A is Char
</p></div><dl class="paramcmts block"><dt class="param">includeTerminator</dt><dd class="cmt"><p>flag to indicate whether the terminator should be discarded or kept</p></dd><dt class="param">lineTerminator</dt><dd class="cmt"><p>the method to use for determine where the line ends</p></dd><dt>returns</dt><dd class="cmt"><p>a Processor containing the sequence of characters from the current element in the input source
</p></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#next" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="next:scalax.io.processing.Processor[A]"></a>
      <a id="next:Processor[Char]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">next</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scala.Char">Char</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Read the next element in the input source if possible.</p><div class="fullcomment"><div class="comment cmt"><p>Read the next element in the input source if possible.</p><p>If there is an element left in the input source a Processor containing that element will be returned, otherwise
the returned processor will be empty.</p><p>Since next will return an empty processor it will terminate the looping in a for-comprehension and the resulting Processor
could be an empty processor.  This can be a problem when reading from multiple input sources.  the opt method can be used to
modify the returned processor so that it returns a Processor[Option[_]] that is never empty.  COnsider the following examples</p><p>Example:</p><pre><span class="kw">for</span> {
  api1 <span class="kw">&lt;-</span> input1.bytes.processor
  api2 <span class="kw">&lt;-</span> input2.bytes.processor
  _ <span class="kw">&lt;-</span> api1.repeatUntilEmpty()
  api1Next <span class="kw">&lt;-</span> api.next
  next <span class="kw">&lt;-</span> api2.next
} println(api1Next)

<span class="kw">for</span> {
  api1 <span class="kw">&lt;-</span> input1.bytes.processor
  api2 <span class="kw">&lt;-</span> input2.bytes.processor
  _ <span class="kw">&lt;-</span> api1.repeatUntilEmpty()
  api1Next <span class="kw">&lt;-</span> api.next
  nextOpt <span class="kw">&lt;-</span> api2.next.opt
} println(api1Next)</pre><p>The two examples appear similar.  The first example will print the bytes from input1 until input2 is empty.  Where
as in example 2 will print all of api1 irregardless of whether api2 is empty or not.</p><p>The reason is that in example 1 (next), next returns an empty processor when input2 is empty and thus the println
is not executed.  In example 2 the Processor is never empty it is either Some or None.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>An empty processor if there are no more elements in the input source or a processor containing the next element
       in the input source.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd><dt>Note</dt><dd><span class="cmt"><p>if the process has a repeatUntilEmpty() method call, next.opt should be preferred over next.
      See repeatUntilEmpty for a more detailed description of why
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#processFactory" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="processFactory:scalax.io.processing.ProcessorFactory"></a>
      <a id="processFactory:ProcessorFactory"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">processFactory</span><span class="result">: <a href="ProcessorFactory.html" class="extype" name="scalax.io.processing.ProcessorFactory">ProcessorFactory</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#repeat" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repeat(times:Int,otherProcessorAPIs:scalax.io.processing.ProcessorAPI[_]*):scalax.io.processing.RepeatUntilEmpty"></a>
      <a id="repeat(Int,ProcessorAPI[_]*):RepeatUntilEmpty"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repeat</span><span class="params">(<span name="times">times: <span class="extype" name="scala.Int">Int</span></span>, <span name="otherProcessorAPIs">otherProcessorAPIs: <a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a>[_]*</span>)</span><span class="result">: <span class="extype" name="scalax.io.processing.RepeatUntilEmpty">RepeatUntilEmpty</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Loops n times or until the provided input sources are all empty.</p><div class="fullcomment"><div class="comment cmt"><p>Loops n times or until the provided input sources are all empty.</p><p>This method is similar to repeatUntilEmpty except it limits the number of repetitions that can be performed.
</p></div><dl class="paramcmts block"><dt class="param">times</dt><dd class="cmt"><p>the maximum number of loops</p></dd><dt class="param">otherProcessorAPIs</dt><dd class="cmt"><p>other input sources to monitor for empty before prematurely ending the loop.
                          If this and otherProcessorAPIs are all empty then the looping will be ended
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#repeatUntilEmpty" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="repeatUntilEmpty(otherProcessorAPIs:scalax.io.processing.ProcessorAPI[_]*):scalax.io.processing.RepeatUntilEmpty"></a>
      <a id="repeatUntilEmpty(ProcessorAPI[_]*):RepeatUntilEmpty"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">repeatUntilEmpty</span><span class="params">(<span name="otherProcessorAPIs">otherProcessorAPIs: <a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a>[_]*</span>)</span><span class="result">: <span class="extype" name="scalax.io.processing.RepeatUntilEmpty">RepeatUntilEmpty</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a Processor that simply repeats until this processor and all of the other input sources that are passed
in are empty or ended.</p><div class="fullcomment"><div class="comment cmt"><p>Create a Processor that simply repeats until this processor and all of the other input sources that are passed
in are empty or ended.  Each repetition generates an integer that can be used to count the number of repetitions
if desired.
</p></div><dl class="paramcmts block"><dt class="param">otherProcessorAPIs</dt><dd class="cmt"><p>other processors to empty (in addition to this) before ending the loop
</p></dd><dt>returns</dt><dd class="cmt"><p>A Processor containing a sequence of whatever elements are returned by the for-comprehension
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd><dt>Note</dt><dd><span class="cmt"><p>repeatUntilEmpty can very easily result in infinite loops because it depends on the following components
of the process/workflow correctly retrieving elements from the input source so that it eventually empties</p><p>The following examples are ways that one can create infinite loops (or loops that last up to Long.MaxValue):</p><pre><span class="kw">for</span> {
  processor1 <span class="kw">&lt;-</span> input.bytes.processor
  processor2 <span class="kw">&lt;-</span> input.bytes.processor
  processor1Loops <span class="kw">&lt;-</span> processor1.repeatUntilEmpty()
    <span class="cmt">// if processor2 is emptied before processor1 there is an infinite loop because</span>
    <span class="cmt">// this section will be the loop and since processor1 is not accessed here we have a loop</span>
    <span class="cmt">// to be safer next1 should be in this section</span>
  processor2Loops <span class="kw">&lt;-</span> processor2.repeatUntilEmpty()
  next1 <span class="kw">&lt;-</span> processor1.next.opt
  next2 <span class="kw">&lt;-</span> processor2.next.opt
} <span class="kw">yield</span> (next1, next2)</pre><pre><span class="kw">for</span> {
  processor1 <span class="kw">&lt;-</span> input.bytes.processor
  processor2 <span class="kw">&lt;-</span> input.bytes.processor
  processor1Loops <span class="kw">&lt;-</span> processor1.repeatUntilEmpty(processor2)
  next1 <span class="kw">&lt;-</span> processor1.next  <span class="cmt">// next.opt should be used here because this can cause</span>
                            <span class="cmt">// an infinite loop.  if processor1 is empty and processor2 is not</span>
                            <span class="cmt">// next produces an empty processor so the next line will not be executed</span>
                            <span class="cmt">// next.opt would always produce an non-empty Processor and therefore</span>
                            <span class="cmt">// should be preferred over next</span>
  next2 <span class="kw">&lt;-</span> processor2.next
} <span class="kw">yield</span> (next1, next2)</pre><pre><span class="kw">for</span> {
  processor1 <span class="kw">&lt;-</span> input.bytes.processor
  processor2 <span class="kw">&lt;-</span> input.bytes.processor
  loops <span class="kw">&lt;-</span> processor1.repeatUntilEmpty(processor2)
  <span class="kw">if</span> loops &lt; <span class="num">100</span>  <span class="cmt">// this guard is dangerous because if there are more than 100 elements in either</span>
                  <span class="cmt">// processor1 or processor2 there is an infinite loop because next1 and next2 never get called</span>
  next1 <span class="kw">&lt;-</span> processor1.next.opt
  next2 <span class="kw">&lt;-</span> processor2.next.opt
} <span class="kw">yield</span> (next1, next2)</pre><p>A safe implementation using repeatUntilEmpty should only execute methods that produce non-empty Processors
or should be done with extreme care.</p><p>for {
  processor1 &lt;- input.bytes.processor
  processor2 &lt;- input.bytes.processor
  processor1Loops &lt;- processor1.repeatUntilEmpty(processor2)
  option1 &lt;- processor1.next.opt
  option2 &lt;- processor2.next.opt
  next1 &lt;- option1
  next2 &lt;- option2
} yield (next1, next2)
}}}
</p></span></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#take" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="take(i:Int):scalax.io.processing.Processor[scala.collection.immutable.Vector[A]]"></a>
      <a id="take(Int):Processor[Vector[Char]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">take</span><span class="params">(<span name="i">i: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scala.collection.immutable.Vector">Vector</span>[<span class="extype" name="scala.Char">Char</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Construct a sequence by taking up to i elements from the input source
</p><div class="fullcomment"><div class="comment cmt"><p>Construct a sequence by taking up to i elements from the input source
</p></div><dl class="paramcmts block"><dt class="param">i</dt><dd class="cmt"><p>the maximum number of elements to take
</p></dd><dt>returns</dt><dd class="cmt"><p>a Seq[A] consisting of the elements taken from the input source
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd></dl></div>
    </li><li name="scalax.io.processing.ProcessorAPI#takeWhile" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="takeWhile(f:A=&gt;Boolean):scalax.io.processing.Processor[Seq[A]]"></a>
      <a id="takeWhile((Char)⇒Boolean):Processor[Seq[Char]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">takeWhile</span><span class="params">(<span name="f">f: (<span class="extype" name="scala.Char">Char</span>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scala.Seq">Seq</span>[<span class="extype" name="scala.Char">Char</span>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Construct a sequence by taking elements from the input source until the function returns false or
there are no more elements in the input source.</p><div class="fullcomment"><div class="comment cmt"><p>Construct a sequence by taking elements from the input source until the function returns false or
there are no more elements in the input source.
</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>the predicate that determines when to stop taking elements
</p></dd><dt>returns</dt><dd class="cmt"><p>a Seq[A] consisting of the elements taken from the input source
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scalax.io.processing.ProcessorAPI">
              <h3>Inherited from <a href="ProcessorAPI.html" class="extype" name="scalax.io.processing.ProcessorAPI">ProcessorAPI</a>[<span class="extype" name="scala.Char">Char</span>]</h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>