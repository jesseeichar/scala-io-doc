<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>scalax.io.processing.Processor</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../lib/template.css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/trait_big.png" />
        <p id="owner"><a name="scalax" class="extype" href="../../package.html">scalax</a>.<a name="scalax.io" class="extype" href="../package.html">io</a>.<a name="scalax.io.processing" class="extype" href="package.html">processing</a></p>
        <h1>Processor</h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="kind">trait</span>
      <span class="symbol"> 
        <span class="name">Processor</span>
        <span class="tparams">[<span name="A">+A</span>]</span>
        <span class="result"> extends AnyRef</span>
      </span>
      </h4>
      
          <div class="fullcommenttop" id="comment"><div class="comment cmt"><p>A point or step in a IO process workflow.</p><p>The processing API is declarative way to process several input streams together.  The allows much more powerful
options beyond what is available using the normal collections-like API available in <a name="scalax.io.LongTraversable" class="extype" href="../LongTraversable.html">LongTraversable</a>.</p><pre>
val firstElems = for {
  processor &lt;- longTraversable.processor
  firstElem &lt;- processor.next
  secondElem &lt;- processor.next
} yield (firstElem, secondElem)

firstElems.acquireAndGet(println)
</pre><p>Ignore for the moment that the above example is trivial.</p><p>The for-comprehension defines the process.  But nothing is executed until the result (firstElems) is accessed with
acquireAndGet.  This is because IO typically accesses resources which must be opened and closed.  When acquireAndGet
is executed. The Processor[ProcessorAPI[A]] obtained from the longTraversable is opened and the first and second element
are read from the processor (via the ProcessorAPI which defines the operations permitted for this process pipeline).
The result is passed to the function that was initially passed to acquireAndGet.  After the function completes the process is closed.</p><p>For more details on how the processing API is used look at the <a name="scalax.io.processing.ProcessorAPI" class="extype" href="ProcessorAPI.html">ProcessorAPI</a> documentation.</p><p>It is possible for a Processor to be empty so acquireAndGet returns an Option to support this case.  Consider:</p><pre>
import scalax.io.JavaConverters._
val result = for {
  p &lt;- List(1,2,3).asInput.bytes.processor
  next &lt;- next
  if false
} yield next

result.acquireAndGet(println)
</pre><p>Obviously the if false means the Processor will not contain any values so the println will not be executed and
None will be retured from acquireAndGet
</p></div><dl class="paramcmts block"><dt class="tparam">A</dt><dd class="cmt"><p>the type of the object that will be the result of running this Processor
</p></dd></dl><dl class="attributes block"> <dt>Self Type</dt><dd><a name="scalax.io.processing.Processor" class="extype" href="">Processor</a>[A]</dd><dt>See also</dt><dd><span class="cmt"><p><a name="scalax.io.processing.ProcessorAPI" class="extype" href="ProcessorAPI.html">ProcessorAPI</a>
</p></span></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent">AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div><div class="toggleContainer block">
          <span class="toggle">Known Subclasses</span>
          <div class="subClasses hiddenContent"><a name="scalax.io.processing.ByteProcessor" class="extype" href="ByteProcessor.html">ByteProcessor</a>, <a name="scalax.io.processing.CharProcessor" class="extype" href="CharProcessor.html">CharProcessor</a>, <a name="scalax.io.processing.OutputProcessor" class="extype" href="OutputProcessor.html">OutputProcessor</a>, <a name="scalax.io.processing.SeekableProcessor" class="extype" href="SeekableProcessor.html">SeekableProcessor</a>, <a name="scalax.io.processing.SpecificApiFactory" class="extype" href="SpecificApiFactory.html">SpecificApiFactory</a>, <a name="scalax.io.processing.WriteCharsProcessor" class="extype" href="WriteCharsProcessor.html">WriteCharsProcessor</a></div>
        </div></div>
        

      <div id="template">

        <div id="mbrsel">
          <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
          <div id="order">
                <span class="filtertype">Ordering</span>
                <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
              </div>
          <div id="ancestors">
                <span class="filtertype">Inherited</span>
                <ol><li class="hideall out"><span>Hide All</span></li>
                <li class="showall in"><span>Show all</span></li></ol>
                <ol id="linearization"><li name="scalax.io.processing.Processor" class="in"><span>Processor</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
              </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
            </div>
        </div>

        

        
        
        <div class="values members" id="values">
              <h3>Abstract Value Members</h3>
              <ol><li visbl="prt" name="scalax.io.processing.Processor#context" data-isabs="true">
      <a id="context:ResourceContext"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">context</span>
        
        <span class="result">: <a name="scalax.io.ResourceContext" class="extype" href="../ResourceContext.html">ResourceContext</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="scalax.io.processing" class="extype" href="package.html">processing</a>] abstract </dd></dl></div>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Concrete Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">##</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#acquireAndGet" data-isabs="false">
      <a id="acquireAndGet[U]((A) ⇒ U):Option[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">acquireAndGet</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (A) ⇒ U</span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the process workflow represented by this Processor and pass the function the result, if the Processor
is nonEmpty.</p><div class="fullcomment"><div class="comment cmt"><p>Execute the process workflow represented by this Processor and pass the function the result, if the Processor
is nonEmpty.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the result of the function within a Some if this processor is Non-empty.  Otherwise the function
will not be executed and None will be returned
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">asInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">clone</span>
        
        <span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">eq</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">equals</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#execute" data-isabs="false">
      <a id="execute():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">execute</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the Processor.</p><div class="fullcomment"><div class="comment cmt"><p>Execute the Processor.  If the result is an iterator then execute() will visit each element
in the iterator to ensure that any processes mapped to that iterator will be executed.</p><p>A typical situation where execute is useful is when the Processor is a side effect processor
like a Processor created by an <a name="scalax.io.processing.OpenOutput" class="extype" href="OpenOutput.html">OpenOutput</a> or <a name="scalax.io.processing.OpenSeekable" class="extype" href="OpenSeekable.html">OpenSeekable</a>
object.  Both typically return Processor[Unit] processors which only perform side-effecting behaviours.</p><p>Example:</p><pre>
val process = for {
  outProcessor &lt;- output.outputProcessor
  inProcessor &lt;- file.asInput.blocks.processor
  _ &lt;- inProcessor.repeatUntilEmpty()
  block &lt;- inProcessor.next
  _ &lt;- outProcessor.write(block)
} yield ()

// the copy has not yet occurred

// will look through each element in the process (and sub-elements
if the process contains a LongTraversable)
process.execute()
</pre></div></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#filter" data-isabs="false">
      <a id="filter((A) ⇒ Boolean):Processor[A]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">filter</span>
        
        <span class="params">(<span name="f">f: (A) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="scalax.io.processing.Processor" class="extype" href="">Processor</a>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Apply a filter to this processor.</p><div class="fullcomment"><div class="comment cmt"><p>Apply a filter to this processor.  If the filter returns false then the resulting Processor will be empty.  It is
not possible to know if the Processor is empty unless acquireAndGet is called because the filter is not called until
acquireOrGet is executed (or the Processor is somehow processed in another way like obtaining the LongTraversable
and traversing that object).
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A new Processor with the filter applied.
</p></dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">finalize</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#flatMap" data-isabs="false">
      <a id="flatMap[U]((A) ⇒ Processor[U]):Processor[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">flatMap</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (A) ⇒ <a name="scalax.io.processing.Processor" class="extype" href="">Processor</a>[U]</span>)</span><span class="result">: <a name="scalax.io.processing.Processor" class="extype" href="">Processor</a>[U]</span>
      </span>
      </h4>
      
    </li><li visbl="pub" name="scalax.io.processing.Processor#foreach" data-isabs="false">
      <a id="foreach[U]((A) ⇒ U):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">foreach</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (A) ⇒ U</span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the Processor and pass the result to the function, much like acquireAndGet but does not return a result
</p>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">getClass</span>
        
        <span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">hashCode</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">isInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#map" data-isabs="false">
      <a id="map[U]((A) ⇒ U):Processor[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">map</span>
        <span class="tparams">[<span name="U">U</span>]</span>
        <span class="params">(<span name="f">f: (A) ⇒ U</span>)</span><span class="result">: <a name="scalax.io.processing.Processor" class="extype" href="">Processor</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Map the contents of this Processor to a new Processor with a new value.</p><div class="fullcomment"><div class="comment cmt"><p>Map the contents of this Processor to a new Processor with a new value.</p><p>The main use case is so Processor work in for-comprehensions but another useful use case is
to convert the value read from a ProcessorAPI to a new value.  Suppose the value read was an integer you might
use map to convert the contained value to a float.
</p></div></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">ne</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notify</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">notifyAll</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#onFailure" data-isabs="false">
      <a id="onFailure[U&gt;:A](PartialFunction[Throwable, Option[U]]):Processor[U]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">onFailure</span>
        <span class="tparams">[<span name="U">U &gt;: A</span>]</span>
        <span class="params">(<span name="handler">handler: <span name="scala.PartialFunction" class="extype">PartialFunction</span>[Throwable, <span name="scala.Option" class="extype">Option</span>[U]]</span>)</span><span class="result">: <a name="scalax.io.processing.Processor" class="extype" href="">Processor</a>[U]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Declare an error handler for handling an error when executing the processor.</p><div class="fullcomment"><div class="comment cmt"><p>Declare an error handler for handling an error when executing the processor.  It is important to realize that
this will catch exceptions caused ONLY by the current processor, not by 'child' Processors.  IE processors
that are executed within a flatmap or map of this processor.</p><p>Examples:</p><pre>
for {
  mainProcessor &lt;- input.bytes.processor
  // if the read fails 1 will be assigned to first and passed to second as the argument of flatmap
  first &lt;- mainProcessor.read onFailure {_ =&gt; -1}
  // if this read fails an exception will be thrown that will NOT be caught by the above onFailure method
  second &lt;- mainProcessor.read
} yield (first,second)
</pre><p>to handle errors of groups of processors a <b>composite</b> processor must be created and the error handler
added to that:</p><pre>
for {
  mainProcessor &lt;- input.bytes.processor
  // define a _composite_ processor containing the sub processor
  // that need to have error handling
  groupProcessor = for {
    first &lt;- mainProcessor.read
    second &lt;- mainProcessor.read
  } yield (first,second)
  // attach the error handler
  tuple &lt;- groupProcessor onFailure {case t =&gt; log(t); None}
} yield tuple
</pre><p>To handle all errors in one place the yielded processor can have the
error handler attached:</p><pre>
val process = for {
  mainProcessor &lt;- input.bytes.processor
  first &lt;- mainProcessor.read
  second &lt;- mainProcessor.read
} yield (first,second)

process.onFailure{case _ =&gt; log(t); None}

process.acquireAndGet(...)
</pre></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>The value that will be returned from the handler.  Also the type of the returned processor</p></dd><dt class="param">handler</dt><dd class="cmt"><p>
       a partial function that can handle the exceptions thrown during the execution of the process.
       If the handler returns a non-empty Option the that value will be used as the value of the processor,
       If the handler returns None then the processor will be an empty processor
       If the handler throws an exception... then normal semantics of an exception are exhibitted.</p></dd><dt>returns</dt><dd class="cmt"><p>A new processor that will behave the same as this except an error during execution will be handled.
</p></dd></dl></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#opt" data-isabs="false">
      <a id="opt:Processor[Option[A]]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">opt</span>
        
        <span class="result">: <a name="scalax.io.processing.Processor" class="extype" href="">Processor</a>[<span name="scala.Option" class="extype">Option</span>[A]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Convert this Processor to a Processor containing an Option.</p><div class="fullcomment"><div class="comment cmt"><p>Convert this Processor to a Processor containing an Option.  Methods such as next return a potentially empty Processor which will,
when in a for comprehension, will stop the process at that point.  Converting the processor to an option allows the process handle
continue and simply handle the possibility of one input source being empty while other continue to provide data.</p><p>Consider the following example:</p><pre>
for {
  idsIn &lt;- ids.bytesAsInts.processor
  attributes &lt;- in.lines().processor
  _ &lt;- idsIn.repeatUntilEmpty(attributes)
  id &lt;- ids.next.opt.orElse(NoId)
  attr &lt;- attributes.next.opt.orElse(&quot;&quot;)
} yield new Record(id,attr)
</pre><p>The above example processes the streams completely even if one ends prematurely.
</p></div></div>
    </li><li visbl="prt" name="scalax.io.processing.Processor#processFactory" data-isabs="false">
      <a id="processFactory:ProcessorFactory"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">processFactory</span>
        
        <span class="result">: <a name="scalax.io.processing.ProcessorFactory" class="extype" href="ProcessorFactory.html">ProcessorFactory</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">synchronized</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">toString</span>
        
        <span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#traversable" data-isabs="false">
      <a id="traversable[B](ProcessorTransformer[B, A, LongTraversable[B]]):LongTraversable[B]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">traversable</span>
        <span class="tparams">[<span name="B">B</span>]</span>
        <span class="params">(<span class="implicit">implicit </span><span name="transformer">transformer: <span name="scalax.io.processing.ProcessorTransformer" class="extype">ProcessorTransformer</span>[B, A, <a name="scalax.io.LongTraversable" class="extype" href="../LongTraversable.html">LongTraversable</a>[B]]</span>)</span><span class="result">: <a name="scalax.io.LongTraversable" class="extype" href="../LongTraversable.html">LongTraversable</a>[B]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Convert the Processor into a LongTraversable if A is a subclass of Iterator.</p><div class="fullcomment"><div class="comment cmt"><p>Convert the Processor into a LongTraversable if A is a subclass of Iterator.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@implicitNotFound</span><span class="args">(<span>
      
      <span name="&quot;The Processor type (A) is not a subclass of Iterator[A] and thus cannot be used to create a LongTraversable.  Check that you have a .repeat___ method in the process pipeline&quot;" class="defval">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>final </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scalax.io.processing.Processor#withFilter" data-isabs="false">
      <a id="withFilter((A) ⇒ Boolean):Processor[A]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol"> 
        <span class="name">withFilter</span>
        
        <span class="params">(<span name="f">f: (A) ⇒ <span name="scala.Boolean" class="extype">Boolean</span></span>)</span><span class="result">: <a name="scalax.io.processing.Processor" class="extype" href="">Processor</a>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Same behavior as for filter.</p>
    </li></ol>
            </div>

        

        <div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>

      </div>
      
      <div id="tooltip"></div>
      
    </body>
      </html>