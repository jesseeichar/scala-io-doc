<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>OutputProcessor - Scala IO - scalax.io.processing.OutputProcessor</title>
          <meta name="description" content="OutputProcessor - Scala IO - scalax.io.processing.OutputProcessor" />
          <meta name="keywords" content="OutputProcessor Scala IO scalax.io.processing.OutputProcessor" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../index.html';
            var hash = 'scalax.io.processing.OutputProcessor';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/class_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="scalax">scalax</a>.<a href="../package.html" class="extype" name="scalax.io">io</a>.<a href="package.html" class="extype" name="scalax.io.processing">processing</a></p>
        <h1>OutputProcessor</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">OutputProcessor</span><span class="result"> extends <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>]</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>A processor that opens an Output Resource allowing for batch processing.  In other words it permits
multiple write operations to be performed on the same opened output.  The OpenOutput class
has essentially the same API as Output except that each method returns a Processor instead of
Unit.</p><p>There is a important difference between returning a Processor or Unit.  Because OpenOutput returns
processor the writing is not done until the processor is executed.</p><p>Examples:</p><p>The following example is useful when one needs to do several output operations together without closing the output
object.</p><pre><span class="kw">for</span> {
  outProcessor <span class="kw">&lt;-</span> Resource.fromOutputStream(stream).outputProcessor
  out = outProcessor.asOutput
} {
  out.write(<span class="lit">"hi"</span>)
  out.write(<span class="num">123</span>)
}</pre><p>This example is interesting because it illustrates that the methods in outProcessor are NOT the same
as in an Output object and to get the expected results writing within the for-comprehension body, the outputProcessor
must be converted to a normal output object and the write actions are performed on that.</p><p>The following example shows how to read and write data from one input to an output</p><pre><span class="kw">val</span> process = <span class="kw">for</span> {
  in1 <span class="kw">&lt;-</span> inResource1.lines.processor
  in2 <span class="kw">&lt;-</span> inResource2.lines.processor
  out <span class="kw">&lt;-</span> Resource.fromFile(<span class="lit">"file"</span>).outputProcessor
  _ <span class="kw">&lt;-</span> in1.repeatUntilEmpty(in2)
  line1 <span class="kw">&lt;-</span> in1.nextOption
  line2 <span class="kw">&lt;-</span> in2.nextOption
  line = line1 orElse line2
  _ <span class="kw">&lt;-</span> out.write(line)
  _ <span class="kw">&lt;-</span> out.write(<span class="lit">"\n"</span>)
} <span class="kw">yield</span> ()

<span class="cmt">// At this point the process has not been executed, just defined</span>
process.execute <span class="cmt">// execute process</span></pre><p>Since the methods in OpenOutput return Process object the methods can be called interleaved
within a process definition as follows:</p><pre><span class="kw">val</span> process = <span class="kw">for</span> {
  in1 <span class="kw">&lt;-</span> inResource1.lines.processor
  in2 <span class="kw">&lt;-</span> inResource2.lines.processor
  out <span class="kw">&lt;-</span> Resource.fromFile(<span class="lit">"file"</span>).outputProcessor
  _ <span class="kw">&lt;-</span> in1.repeatUntilEmpty(in2)
  line1 <span class="kw">&lt;-</span> in1.nextOption
  _ <span class="kw">&lt;-</span> out.write(line1)
  line2 <span class="kw">&lt;-</span> in2.nextOption
  _ <span class="kw">&lt;-</span> out.write(line2)
} <span class="kw">yield</span> out.asOutput.write(<span class="lit">"\n"</span>)

<span class="cmt">// At this point the process has not been executed, just defined</span>
process.execute <span class="cmt">// execute process</span></pre><p>In this example notice that the writing in the for-comprehension body converts the outputProcessor to an Output
object before writing otherwise the write will not be executed.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>], <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="scalax.io.processing.OutputProcessor"><span>OutputProcessor</span></li><li class="in" name="scalax.io.processing.Processor"><span>Processor</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        <div id="constructors" class="members">
              <h3>Instance Constructors</h3>
              <ol><li name="scalax.io.processing.OutputProcessor#&lt;init&gt;" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="&lt;init&gt;(resource:scalax.io.OutputResource[java.nio.channels.WritableByteChannel]):scalax.io.processing.OutputProcessor"></a>
      <a id="&lt;init&gt;:OutputProcessor"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">new</span>
      </span>
      <span class="symbol">
        <span class="name">OutputProcessor</span><span class="params">(<span name="resource">resource: <a href="../OutputResource.html" class="extype" name="scalax.io.OutputResource">OutputResource</a>[<span class="extype" name="java.nio.channels.WritableByteChannel">WritableByteChannel</span>]</span>)</span>
      </span>
      </h4>
      <p class="shortcomment cmt"></p><div class="fullcomment"><div class="comment cmt"></div><dl class="paramcmts block"><dt class="param">resource</dt><dd class="cmt"><p>the resource to use in the process
</p></dd></dl></div>
    </li></ol>
            </div>

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scalax.io.processing.Processor#acquireAndGet" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="acquireAndGet[U](f:A=&gt;U):Option[U]"></a>
      <a id="acquireAndGet[U]((OpenOutput)⇒U):Option[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">acquireAndGet</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>) ⇒ <span class="extype" name="scalax.io.processing.Processor.acquireAndGet.U">U</span></span>)</span><span class="result">: <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scalax.io.processing.Processor.acquireAndGet.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the process workflow represented by this Processor and pass the function the result, if the Processor
is nonEmpty.</p><div class="fullcomment"><div class="comment cmt"><p>Execute the process workflow represented by this Processor and pass the function the result, if the Processor
is nonEmpty.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the result of the function within a Some if this processor is Non-empty.  Otherwise the function
will not be executed and None will be returned
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd><dt>Note</dt><dd><span class="cmt"><p>If A is an iterator do not return it since it might not function outside the scope of acquireAndGet.
</p></span></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">java.lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scalax.io.processing.OutputProcessor#context" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="context:scalax.io.ResourceContext"></a>
      <a id="context:ResourceContext"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">context</span><span class="result">: <a href="../ResourceContext.html" class="extype" name="scalax.io.ResourceContext">ResourceContext</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="scalax.io.processing.OutputProcessor">OutputProcessor</a> → <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scalax.io.processing.Processor#execute" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="execute():Unit"></a>
      <a id="execute():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">execute</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the Processor.</p><div class="fullcomment"><div class="comment cmt"><p>Execute the Processor.  If the result is an iterator then execute() will visit each element
in the iterator to ensure that any processes mapped to that iterator will be executed.</p><p>A typical situation where execute is useful is when the Processor is a side effect processor
like a Processor created by an <a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">scalax.io.processing.OpenOutput</a> or <a href="OpenSeekable.html" class="extype" name="scalax.io.processing.OpenSeekable">scalax.io.processing.OpenSeekable</a>
object.  Both typically return Processor[Unit] processors which only perform side-effecting behaviours.</p><p>Example:</p><pre><span class="kw">val</span> process = <span class="kw">for</span> {
  outProcessor <span class="kw">&lt;-</span> output.outputProcessor
  inProcessor <span class="kw">&lt;-</span> file.asInput.blocks.processor
  _ <span class="kw">&lt;-</span> inProcessor.repeatUntilEmpty()
  block <span class="kw">&lt;-</span> inProcessor.next
  _ <span class="kw">&lt;-</span> outProcessor.write(block)
} <span class="kw">yield</span> ()

<span class="cmt">// the copy has not yet occurred</span>

<span class="cmt">// will look through each element in the process (and sub-elements</span>
<span class="kw">if</span> the process contains a LongTraversable)
process.execute()</pre></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scalax.io.processing.Processor#filter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="filter(f:A=&gt;Boolean):scalax.io.processing.Processor[A]"></a>
      <a id="filter((OpenOutput)⇒Boolean):Processor[OpenOutput]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">filter</span><span class="params">(<span name="f">f: (<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Apply a filter to this processor.</p><div class="fullcomment"><div class="comment cmt"><p>Apply a filter to this processor.  If the filter returns false then the resulting Processor will be empty.  It is
not possible to know if the Processor is empty unless acquireAndGet is called because the filter is not called until
acquireOrGet is executed (or the Processor is somehow processed in another way like obtaining the LongTraversable
and traversing that object).
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A new Processor with the filter applied.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<span class="extype" name="java.lang">java.lang</span>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scalax.io.processing.Processor#flatMap" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMap[U](f:A=&gt;scalax.io.processing.Processor[U]):scalax.io.processing.Processor[U]"></a>
      <a id="flatMap[U]((OpenOutput)⇒Processor[U]):Processor[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMap</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>) ⇒ <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scalax.io.processing.Processor.flatMap.U">U</span>]</span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scalax.io.processing.Processor.flatMap.U">U</span>]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scalax.io.processing.Processor#foreach" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="foreach[U](f:A=&gt;U):Unit"></a>
      <a id="foreach[U]((OpenOutput)⇒U):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">foreach</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>) ⇒ <span class="extype" name="scalax.io.processing.Processor.foreach.U">U</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Execute the Processor and pass the result to the function, much like acquireAndGet but does not return a result
</p><div class="fullcomment"><div class="comment cmt"><p>Execute the Processor and pass the result to the function, much like acquireAndGet but does not return a result
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scalax.io.processing.Processor#future" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="future:scala.concurrent.Future[Option[A]]"></a>
      <a id="future:Future[Option[OpenOutput]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">future</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Option">Option</span>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Start the execution of the process in another thread and return a
future for accessing the result when it is ready.</p><div class="fullcomment"><div class="comment cmt"><p>Start the execution of the process in another thread and return a
future for accessing the result when it is ready.</p><p>It is important to realize that if the result of the process is
a LongTraversable the processing will not in fact be executed
because LongTraversables are non-strict (lazy).</p><p>In the case where the Processor has a resulting type of
LongTraversable, one must execute either futureExec which will
execute all LongTraversables recursively in the process or
obtain the LongTraversable (normally by calling the traversable method)
and visit each element in the LongTraversable.
(See <a href="../LongTraversable.html" class="extype" name="scalax.io.LongTraversable">scalax.io.LongTraversable</a>.async)</p><p>See futureExec docs for examples when to use futureExec.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>A Future that will return the result of executing the process
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scalax.io.processing.Processor#futureExec" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="futureExec():scala.concurrent.Future[Unit]"></a>
      <a id="futureExec():Future[Unit]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">futureExec</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.concurrent.Future">Future</span>[<span class="extype" name="scala.Unit">Unit</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Call execute asynchronously.</p><div class="fullcomment"><div class="comment cmt"><p>Call execute asynchronously.</p><p>The use of this method over future is that this will recursively
visit each element of a LongTraversable if the Processor contains a
LongTraversable.</p><p>For Example:</p><pre><span class="kw">val</span> processor = <span class="kw">for</span> {
  in <span class="kw">&lt;-</span> in.blocks().processor
  outApi <span class="kw">&lt;-</span> out.outputProcessor
  _ <span class="kw">&lt;-</span> in.repeatUntilEmpty()
  block <span class="kw">&lt;-</span> in.next
  _ <span class="kw">&lt;-</span> outApi.write(block)
} <span class="kw">yield</span> ()

 processor.futureExec()</pre><p>The example illustrates a case where futureExec is desired because
(as a result of the repeatUntilEmpty) the contained object
is a LongTraversable.  If future is executed the write will
not be executed because the writes occur only when an element in
the LongTraversable is visited.</p><p>An equivalent way of writing the previous example is:</p><pre><span class="kw">val</span> processor2 = <span class="kw">for</span> {
  in <span class="kw">&lt;-</span> in.blocks().processor
  outApi <span class="kw">&lt;-</span> out.outputProcessor
  _ <span class="kw">&lt;-</span> in.repeatUntilEmpty()
  block <span class="kw">&lt;-</span> in.next
} <span class="kw">yield</span> outApi.asOutput.write(block)

processor.futureExec()</pre></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a future so one can observe when the process is finished
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scalax.io.processing.OutputProcessor#init" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="init:scalax.io.processing.Opened[scalax.io.processing.OpenOutput]{defexecute():Some[scalax.io.processing.OpenOutput]}"></a>
      <a id="init:Opened[OpenOutput]{defexecute():Some[scalax.io.processing.OpenOutput]}"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">init</span><span class="result">: <span class="extype" name="scalax.io.processing.Opened">Opened</span>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>] { def execute(): Some[scalax.io.processing.OpenOutput] }</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="scalax.io.processing.OutputProcessor">OutputProcessor</a> → <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scalax.io.processing.Processor#map" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="map[U](f:A=&gt;U):scalax.io.processing.Processor[U]"></a>
      <a id="map[U]((OpenOutput)⇒U):Processor[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">map</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>) ⇒ <span class="extype" name="scalax.io.processing.Processor.map.U">U</span></span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scalax.io.processing.Processor.map.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Map the contents of this Processor to a new Processor with a new value.</p><div class="fullcomment"><div class="comment cmt"><p>Map the contents of this Processor to a new Processor with a new value.</p><p>The main use case is so Processor work in for-comprehensions but another useful use case is
to convert the value read from a ProcessorAPI to a new value.  Suppose the value read was an integer you might
use map to convert the contained value to a float.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scalax.io.processing.Processor#onFailure" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="onFailure[U&gt;:A](handler:PartialFunction[Throwable,Option[U]]):scalax.io.processing.Processor[U]"></a>
      <a id="onFailure[U&gt;:OpenOutput](PartialFunction[Throwable,Option[U]]):Processor[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">onFailure</span><span class="tparams">[<span name="U">U &gt;: <a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a></span>]</span><span class="params">(<span name="handler">handler: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[<span class="extype" name="scala.Throwable">Throwable</span>, <span class="extype" name="scala.Option">Option</span>[<span class="extype" name="scalax.io.processing.Processor.onFailure.U">U</span>]]</span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scalax.io.processing.Processor.onFailure.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Declare an error handler for handling an error when executing the processor.</p><div class="fullcomment"><div class="comment cmt"><p>Declare an error handler for handling an error when executing the processor.  It is important to realize that
this will catch exceptions caused ONLY by the current processor, not by 'child' Processors.  IE processors
that are executed within a flatmap or map of this processor.</p><p>Examples:</p><pre><span class="kw">for</span> {
  mainProcessor <span class="kw">&lt;-</span> input.bytes.processor
  <span class="cmt">// if the read fails 1 will be assigned to first and passed to second as the argument of flatmap</span>
  first <span class="kw">&lt;-</span> mainProcessor.read onFailure {_ <span class="kw">=&gt;</span> -<span class="num">1</span>}
  <span class="cmt">// if this read fails an exception will be thrown that will NOT be caught by the above onFailure method</span>
  second <span class="kw">&lt;-</span> mainProcessor.read
} <span class="kw">yield</span> (first,second)</pre><p>to handle errors of groups of processors a <b>composite</b> processor must be created and the error handler
added to that:</p><pre><span class="kw">for</span> {
  mainProcessor <span class="kw">&lt;-</span> input.bytes.processor
  <span class="cmt">// define a _composite_ processor containing the sub processor</span>
  <span class="cmt">// that need to have error handling</span>
  groupProcessor = <span class="kw">for</span> {
    first <span class="kw">&lt;-</span> mainProcessor.read
    second <span class="kw">&lt;-</span> mainProcessor.read
  } <span class="kw">yield</span> (first,second)
  <span class="cmt">// attach the error handler</span>
  tuple <span class="kw">&lt;-</span> groupProcessor onFailure {<span class="kw">case</span> t <span class="kw">=&gt;</span> log(t); <span class="std">None</span>}
} <span class="kw">yield</span> tuple</pre><p>To handle all errors in one place the yielded processor can have the
error handler attached:</p><pre><span class="kw">val</span> process = <span class="kw">for</span> {
  mainProcessor <span class="kw">&lt;-</span> input.bytes.processor
  first <span class="kw">&lt;-</span> mainProcessor.read
  second <span class="kw">&lt;-</span> mainProcessor.read
} <span class="kw">yield</span> (first,second)

process.onFailure{<span class="kw">case</span> _ <span class="kw">=&gt;</span> log(t); <span class="std">None</span>}

process.acquireAndGet(...)</pre></div><dl class="paramcmts block"><dt class="tparam">U</dt><dd class="cmt"><p>The value that will be returned from the handler.  Also the type of the returned processor</p></dd><dt class="param">handler</dt><dd class="cmt"><p>
       a partial function that can handle the exceptions thrown during the execution of the process.
       If the handler returns a non-empty Option the that value will be used as the value of the processor,
       If the handler returns None then the processor will be an empty processor
       If the handler throws an exception... then normal semantics of an exception are exhibitted.</p></dd><dt>returns</dt><dd class="cmt"><p>A new processor that will behave the same as this except an error during execution will be handled.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scalax.io.processing.Processor#opt" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="opt:scalax.io.processing.Processor[Option[A]]"></a>
      <a id="opt:Processor[Option[OpenOutput]]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">opt</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<span class="extype" name="scala.Option">Option</span>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>]]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Convert this Processor to a Processor containing an Option.</p><div class="fullcomment"><div class="comment cmt"><p>Convert this Processor to a Processor containing an Option.  Methods such as next return a potentially empty Processor which will,
when in a for comprehension, will stop the process at that point.  Converting the processor to an option allows the process handle
continue and simply handle the possibility of one input source being empty while other continue to provide data.</p><p>Consider the following example:</p><pre><span class="kw">for</span> {
  idsIn <span class="kw">&lt;-</span> ids.bytesAsInts.processor
  attributes <span class="kw">&lt;-</span> in.lines().processor
  _ <span class="kw">&lt;-</span> idsIn.repeatUntilEmpty(attributes)
  id <span class="kw">&lt;-</span> ids.next.opt.orElse(NoId)
  attr <span class="kw">&lt;-</span> attributes.next.opt.orElse(<span class="lit">""</span>)
} <span class="kw">yield</span> <span class="kw">new</span> Record(id,attr)</pre><p>The above example processes the streams completely even if one ends prematurely.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scalax.io.processing.Processor#processFactory" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="processFactory:scalax.io.processing.ProcessorFactory"></a>
      <a id="processFactory:ProcessorFactory"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">processFactory</span><span class="result">: <a href="ProcessorFactory.html" class="extype" name="scalax.io.processing.ProcessorFactory">ProcessorFactory</a></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd><dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scalax.io.processing.Processor#timeout" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="timeout(timeout:scala.concurrent.duration.Duration):scalax.io.processing.TimingOutProcessor[A]"></a>
      <a id="timeout(Duration):TimingOutProcessor[OpenOutput]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">timeout</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.concurrent.duration.Duration">Duration</span></span>)</span><span class="result">: <span class="extype" name="scalax.io.processing.TimingOutProcessor">TimingOutProcessor</span>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Create a modified processor that will throw a <span class="extype" name="java.util.concurrent.TimeoutException">java.util.concurrent.TimeoutException</span>
if the process takes longer than the provided timeout.</p><div class="fullcomment"><div class="comment cmt"><p>Create a modified processor that will throw a <span class="extype" name="java.util.concurrent.TimeoutException">java.util.concurrent.TimeoutException</span>
if the process takes longer than the provided timeout.
</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the length of time before the timeout exception is thrown</p></dd><dt>returns</dt><dd class="cmt"><p>a new processor with a timeout associated with it
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scalax.io.processing.Processor#traversable" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="traversable[B](implicittransformer:scalax.io.processing.ProcessorTransformer[B,A,scalax.io.LongTraversable[B]]):scalax.io.LongTraversable[B]"></a>
      <a id="traversable[B](ProcessorTransformer[B,OpenOutput,LongTraversable[B]]):LongTraversable[B]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">traversable</span><span class="tparams">[<span name="B">B</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="transformer">transformer: <span class="extype" name="scalax.io.processing.ProcessorTransformer">ProcessorTransformer</span>[<span class="extype" name="scalax.io.processing.Processor.traversable.B">B</span>, <a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>, <a href="../LongTraversable.html" class="extype" name="scalax.io.LongTraversable">LongTraversable</a>[<span class="extype" name="scalax.io.processing.Processor.traversable.B">B</span>]]</span>)</span><span class="result">: <a href="../LongTraversable.html" class="extype" name="scalax.io.LongTraversable">LongTraversable</a>[<span class="extype" name="scalax.io.processing.Processor.traversable.B">B</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Convert the Processor into a LongTraversable if A is a subclass of Iterator.</p><div class="fullcomment"><div class="comment cmt"><p>Convert the Processor into a LongTraversable if A is a subclass of Iterator.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd><dt>Annotations</dt><dd>
                <span class="name">@implicitNotFound</span><span class="args">(<span>
      
      <span class="defval" name="&quot;The Processor type (A) is not a subclass of Iterator[A] and thus cannot be used to create a LongTraversable.  Check that you have a .repeat___ method in the process pipeline&quot;">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scalax.io.processing.Processor#withFilter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="withFilter(f:A=&gt;Boolean):scalax.io.processing.Processor[A]"></a>
      <a id="withFilter((OpenOutput)⇒Boolean):Processor[OpenOutput]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">withFilter</span><span class="params">(<span name="f">f: (<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Same behavior as for filter.</p><div class="fullcomment"><div class="comment cmt"><p>Same behavior as for filter.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a></dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scalax.io.processing.Processor">
              <h3>Inherited from <a href="Processor.html" class="extype" name="scalax.io.processing.Processor">Processor</a>[<a href="OpenOutput.html" class="extype" name="scalax.io.processing.OpenOutput">OpenOutput</a>]</h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>